<!DOCTYPE html>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"blog.jerrychu.top","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="++">
<meta property="og:url" content="http://blog.jerrychu.top/index.html">
<meta property="og:site_name" content="++">
<meta property="article:author" content="JerryChu">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://blog.jerrychu.top/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-Hans'
  };
</script>

  <title>++</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">++</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="home                          //首页 fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="archive          //归档 fa-fw"></i>Archives</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="tags                     //标签 fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="user                   //关于 fa-fw"></i>About</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

  <a href="https://github.com/jerrychu" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://blog.jerrychu.top/2020/11/29/Swift%E5%AD%97%E7%AC%A6%E4%B8%B2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="JerryChu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="++">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/11/29/Swift%E5%AD%97%E7%AC%A6%E4%B8%B2/" class="post-title-link" itemprop="url">Swift字符串性能问题</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-11-29 14:14:14 / Modified: 16:10:30" itemprop="dateCreated datePublished" datetime="2020-11-29T14:14:14+08:00">2020-11-29</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>用Swift做算法题时，经常遇到输入为<code>String</code>的情况，但是用Swift的<code>String</code> API遍历元素非常麻烦，每次都得Google一下。做这类题目时，我一般会直接把<code>String</code>转成<code>Array</code>，然后就能愉快地用数组下标访问元素了。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 直接使用String遍历字符串</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..&lt;s.<span class="built_in">count</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> ch = s[s.index(s.startIndex, offsetBy: i)]</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 转换为Array再遍历字符串</span></span><br><span class="line"><span class="keyword">let</span> array = <span class="type">Array</span>(string)</span><br><span class="line"><span class="keyword">for</span> ch <span class="keyword">in</span> array &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是转换为<code>Array</code>毕竟会产生额外的内存消耗，身为有追求的程序员，咱必须最求严格要求自己。于是有一天刷到<a href="https://leetcode-cn.com/problems/valid-anagram/" target="_blank" rel="noopener">有效的字母异位词</a>这个题目时，我决定直接使用Swift的<code>String</code> API来写。  </p>
<p>题目很简单，主要步骤就是遍历字符串，并存储在哈希表中。直接上代码（解法也很朴素😳）：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isAnagram</span><span class="params">(<span class="number">_</span> s: String, <span class="number">_</span> t: String)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">    <span class="keyword">guard</span> s.<span class="built_in">count</span> == t.<span class="built_in">count</span> <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> <span class="built_in">map</span> = [<span class="type">Character</span>: <span class="type">Int</span>]()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..&lt;s.<span class="built_in">count</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> ch = s[s.index(s.startIndex, offsetBy: i)]</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">map</span>[ch] != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="built_in">map</span>[ch] = <span class="built_in">map</span>[ch]! + <span class="number">1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">map</span>[ch] = <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..&lt;t.<span class="built_in">count</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> ch = t[t.index(t.startIndex, offsetBy: i)]</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">map</span>[ch] != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="built_in">map</span>[ch] = <span class="built_in">map</span>[ch]! - <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">map</span>[ch] == <span class="number">0</span> &#123;</span><br><span class="line">                <span class="built_in">map</span>[ch] = <span class="literal">nil</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">map</span>.<span class="built_in">count</span> == <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一提交，超时了。当输入为特别长（如50000）的字符串时，提示上述代码的运行时间超过限制。<br>我反复研究了自己写的代码，<code>O(n)</code>的时间复杂度，没啥毛病啊。怀着试一试的心态，我又提交了一次，还是超时。。  </p>
<p>实在没办法了，我决定把<code>String</code>转成<code>Array</code>，然后直接基于<code>Array</code>来遍历。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isAnagram</span><span class="params">(<span class="number">_</span> s: String, <span class="number">_</span> t: String)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">    <span class="keyword">guard</span> s.<span class="built_in">count</span> == t.<span class="built_in">count</span> <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> <span class="built_in">map</span> = [<span class="type">Character</span>: <span class="type">Int</span>]()</span><br><span class="line">    <span class="keyword">let</span> sArray = <span class="type">Array</span>(s)</span><br><span class="line">    <span class="keyword">let</span> tArray = <span class="type">Array</span>(t)</span><br><span class="line">    <span class="keyword">for</span> ch <span class="keyword">in</span> sArray &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">map</span>[ch] != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="built_in">map</span>[ch] = <span class="built_in">map</span>[ch]! + <span class="number">1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">map</span>[ch] = <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> ch <span class="keyword">in</span> tArray &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">map</span>[ch] != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="built_in">map</span>[ch] = <span class="built_in">map</span>[ch]! - <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">map</span>[ch] == <span class="number">0</span> &#123;</span><br><span class="line">                <span class="built_in">map</span>[ch] = <span class="literal">nil</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">map</span>.<span class="built_in">count</span> == <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再提交，竟然就通过了😂。</p>
<h2 id="性能测试"><a href="#性能测试" class="headerlink" title="性能测试"></a>性能测试</h2><p>难道是LeetCode的问题？我决定用Swift Playground跑个性能测试看看结果。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PerformanceTest</span>: <span class="title">XCTestCase</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> string = <span class="string">"..."</span> <span class="comment">// 长度为50000的字符串</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">testPerformanceOfArray</span><span class="params">()</span></span> &#123;</span><br><span class="line">        measure &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="number">_</span> = solution.isAnagramUsingArrayApi(string, string)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">testPerformanceOfString</span><span class="params">()</span></span> &#123;</span><br><span class="line">        measure &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="number">_</span> = solution.isAnagramUsingStringApi(string, string)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">PerformanceTest</span>.defaultTestSuite.run()</span><br></pre></td></tr></table></figure>

<ul>
<li>使用Array的性能测试结果：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;unknown&gt;:0: Test Case &#39;-[__lldb_expr_20.PerformanceTest testPerformanceOfArray]&#39; measured [Time, seconds] average: 1.709, relative standard deviation: 4.094%, values: [1.792613, 1.672665, 1.666029, 1.608078, 1.619144, 1.832425, 1.732586, 1.706398, 1.772683, 1.683238], performanceMetricID:com.apple.XCTPerformanceMetric_WallClockTime, baselineName: &quot;&quot;, baselineAverage: , maxPercentRegression: 10.000%, maxPercentRelativeStandardDeviation: 10.000%, maxRegression: 0.100, maxStandardDeviation: 0.100</span><br></pre></td></tr></table></figure>

<p>平均运行时间为 <strong>1.709 s</strong>。</p>
<ul>
<li>使用String的性能测试结果：  </li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;unknown&gt;:0: Test Case &#39;-[__lldb_expr_28.PerformanceTest testPerformanceOfString]&#39; measured [Time, seconds] average: 33.674, relative standard deviation: 1.500%, values: [32.627662, 33.954215, 34.245659, 34.001036, 33.695257, 34.446044, 33.701735, 33.209314, 33.351506, 33.507718], performanceMetricID:com.apple.XCTPerformanceMetric_WallClockTime, baselineName: &quot;&quot;, baselineAverage: , maxPercentRegression: 10.000%, maxPercentRelativeStandardDeviation: 10.000%, maxRegression: 0.100, maxStandardDeviation: 0.100</span><br></pre></td></tr></table></figure>

<p>平均运行时间为 <strong>33.674 s</strong>。</p>
<p>眼前的结果不禁令人陷入沉思，Swift的<code>String</code> API不仅难用，性能也不行，到底是出了什么问题？</p>
<h2 id="Swift的String变迁史"><a href="#Swift的String变迁史" class="headerlink" title="Swift的String变迁史"></a>Swift的String变迁史</h2><p>通过阅读Swift的文档，我们知道<code>String</code>其实是一个<code>Collection</code>类型（遵循<code>Collection</code>协议），也就是说，<code>String</code>是可以使用下标访问的。  </p>
<blockquote>
<p>A Unicode string value that is a collection of characters.<br>A string is a series of characters, such as “Swift”, that forms a collection. Strings in Swift are Unicode correct and locale insensitive, and are designed to be efficient. The String type bridges with the Objective-C class NSString and offers interoperability with C functions that works with strings.</p>
</blockquote>
<p>在Swift语言的历史上，<code>String</code>有三次比较大的改动：</p>
<ol>
<li>Swift1 版本，遵循<code>Collection</code>协议</li>
<li>Swift2-3 版本，不再遵循<code>Collection</code>协议</li>
<li>Swift4 版本，重新遵循<code>Collection</code>协议</li>
</ol>
<p>可以看到，Swift Core Team对<code>String</code>该何如实现也是有过争议和动摇的，但是最终还是让遵循<code>Collection</code>协议了。<br>为什么最终会遵循<code>Collection</code>协议呢？我理解主要有以下两点：</p>
<ul>
<li>更易于理解，字符串其实就是字符的集合</li>
<li>从设计上，<code>String</code>和<code>Collection</code>可以直接用一套API</li>
</ul>
<p>关于最终的选型，Swift Core Team有更深入的思考，有兴趣的可以继续阅读<a href="https://github.com/apple/swift/blob/main/docs/StringManifesto.md" target="_blank" rel="noopener">https://github.com/apple/swift/blob/main/docs/StringManifesto.md</a>。  </p>
<p>遵循<code>Collection</code>协议本身对开发者应该是个好事，因为这样更容易理解，一套API就可以搞定所有常用的集合类型。但是为什么<code>String</code>的接口这么复杂，性能也不高呢？</p>
<h2 id="字符串一直都很难"><a href="#字符串一直都很难" class="headerlink" title="字符串一直都很难"></a>字符串一直都很难</h2><p>字符串一直是个老大难的问题，Unicode也一直是开发者的噩梦。</p>
<p>上文说过，Swift的<code>String</code>对外表现是字符的集合，其底层实现其实是<code>UTF-8</code>编码单位的集合，每个字符由1到4个<code>UTF-8</code>编码单位组成。也就是说，<code>String</code>的每一个元素的长度是不一定相等的，我们无法直接使用<code>Int</code>类型的数字下标去访问集合中的字符，这也是<code>String</code>与<code>Array</code>等其他集合类型的最大区别。  </p>
<p>正是由于这个原因，Swift不得不放弃<code>Int</code>类型的下标，在内部通过自定义的<code>Index</code>类型记录对应元素的偏移量，并提供通过<code>Index</code>进行元素访问的接口。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// A position of a character or code unit in a string.</span></span><br><span class="line">@frozen <span class="keyword">public</span> <span class="class"><span class="keyword">struct</span> <span class="title">Index</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 读取string的第2个字符</span></span><br><span class="line"><span class="keyword">let</span> string = <span class="string">"Swift"</span></span><br><span class="line"><span class="keyword">let</span> index = string.index(string.startIndex, offsetBy: <span class="number">1</span>)</span><br><span class="line">string[index]</span><br></pre></td></tr></table></figure>

<h2 id="对性能的影响"><a href="#对性能的影响" class="headerlink" title="对性能的影响"></a>对性能的影响</h2><p>无论是<code>Int</code>类型的下标还是<code>Index</code>类型的下标，作为集合类型，通过下标访问元素的时间复杂度都应该是<code>O(1)</code>，那为什么Swift中方法<code>String</code>的元素会比访问<code>Array</code>的元素性能差这么多呢？  </p>
<p>问题就出在<code>Index</code>的计算上。也就是</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> index = string.index(string.startIndex, offsetBy: <span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<p>对于每个 <em>index</em> ，都需要根据当前 <em>string</em> 的实际字符情况计算真实的偏移量，不难看出，这一步的时间复杂度是 <em>O(n)*。<br>而对于数组来说，不需要计算这个 *index</em> ，自然性能会更高。 </p>
<p>回到最开始的算法题，如下代码中，遍历获取字符串 <em>s</em> 中的字符时，每次都会重新计算 <em>index</em>，导致运行时间过长。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isAnagram</span><span class="params">(<span class="number">_</span> s: String, <span class="number">_</span> t: String)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..&lt;s.<span class="built_in">count</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> ch = s[s.index(s.startIndex, offsetBy: i)]</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">map</span>[ch] != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="built_in">map</span>[ch] = <span class="built_in">map</span>[ch]! + <span class="number">1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">map</span>[ch] = <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那如果不要每次都重新计算 <em>index</em> ，而是保存当前的 <em>index</em> 结果，每次只需继续向后偏移 1 位，会不会提升性能呢？<br>我们将上面的代码稍作修改，重新跑一边性能测试。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isAnagram</span><span class="params">(<span class="number">_</span> s: String, <span class="number">_</span> t: String)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">var</span> index = s.startIndex</span><br><span class="line">    <span class="keyword">for</span> <span class="number">_</span> <span class="keyword">in</span> <span class="number">0</span>..&lt;s.<span class="built_in">count</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> ch = s[index]</span><br><span class="line">        index = s.index(index, offsetBy: <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">map</span>[ch] != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="built_in">map</span>[ch] = <span class="built_in">map</span>[ch]! + <span class="number">1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">map</span>[ch] = <span class="number">1</span> </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;unknown&gt;:0: Test Case &#39;-[__lldb_expr_30.PerformanceTest testPerformanceOfString]&#39; measured [Time, seconds] average: 20.650, relative standard deviation: 2.606%, values: [20.168230, 20.097321, 21.516863, 21.269714, 20.570309, 21.345641, 20.949756, 20.261627, 20.081277, 20.239225], performanceMetricID:com.apple.XCTPerformanceMetric_WallClockTime, baselineName: &quot;&quot;, baselineAverage: , maxPercentRegression: 10.000%, maxPercentRelativeStandardDeviation: 10.000%, maxRegression: 0.100, maxStandardDeviation: 0.100</span><br></pre></td></tr></table></figure>

<p>果然，平均运行时间降低到了 <strong>20.650s</strong>，但是还是没有预期的快，更深层次的原因有待继续追踪。另外，String内部没有对index的计算结果做缓存吗？这些问题留待接下来的文章继续探讨吧。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Swift中的字符串历经多个版本的变迁，依然令人非常头疼。其之所以使用起来麻烦，是因为内部字符长度长度不固定，无法直接使用普通的数字下标进行索引，必须维护内部特殊的<code>Index</code>。而<code>Index</code>需要经过计算得出，也就带来了访问字符串元素时的性能问题。  </p>
<p>但是无论如何，Swift一直在对<code>String</code>进行持续优化，包括提供更方便的接口（如<a href="https://github.com/apple/swift-evolution/blob/master/proposals/0265-offset-indexing-and-slicing.md" target="_blank" rel="noopener">Offset-Based Access</a>）等。从Swift的设计理念上来说，正确性比易用性更重要。为了保证代码不出问题，稍微麻烦一点也是可以接受的。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://github.com/apple/swift/blob/main/docs/StringManifesto.md" target="_blank" rel="noopener">https://github.com/apple/swift/blob/main/docs/StringManifesto.md</a></li>
<li><a href="https://kemchenj.github.io/2019-10-07/" target="_blank" rel="noopener">https://kemchenj.github.io/2019-10-07/</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://blog.jerrychu.top/2020/11/22/Swift%E5%85%A8%E6%A0%88%E9%A1%B9%E7%9B%AE%E8%AE%A1%E5%88%92/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="JerryChu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="++">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/11/22/Swift%E5%85%A8%E6%A0%88%E9%A1%B9%E7%9B%AE%E8%AE%A1%E5%88%92/" class="post-title-link" itemprop="url">Swift全栈项目计划</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-11-22 14:16:19 / Modified: 15:24:55" itemprop="dateCreated datePublished" datetime="2020-11-22T14:16:19+08:00">2020-11-22</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>最近主要在学习<code>Swift</code>和<code>SwiftUI</code>，准备搞一个全栈使用<code>Swift</code>的完整项目，在实际工程中进行深入探索。同时我也一直想做一个完整的全栈开发项目，提升下姿势水平。</p>
<p>目前的初步想法是做一个电影相关的APP，主要涉及的技术栈有：</p>
<ul>
<li>客户端</li>
<li>Web端</li>
<li>Server</li>
<li>数据库</li>
</ul>
<h2 id="客户端-amp-Web端"><a href="#客户端-amp-Web端" class="headerlink" title="客户端 &amp; Web端"></a>客户端 &amp; Web端</h2><p>因为最主要的目标是学习<code>SwiftUI</code>，所以iOS客户端我会使用<code>SwiftUI</code>来写，这样就直接实现了苹果的“跨平台”，支持所有<code>Apple Platform</code>（iOS/iPadOS/watchOS/macOS)。  </p>
<p>Android端优先级比较低，毕竟不如iOS熟悉，后面可以考虑用 <em>Weex</em> 等跨平台方案来实现，正好横向对比下 <em>真实的跨平台</em>（iOS/Android/Web）和 <em>虚假的跨平台</em>（iOS/iPadOS/watchOS/macOS）到底谁更有前途。（好像不用对比也能知道💔）</p>
<p>正好 <em>Weex</em> 也支持Web端，一套代码搞定Android和Web，也能顺便学习下<code>JS</code>大法和<code>VUE</code>。</p>
<p>那么问题来了：</p>
<blockquote>
<p>为啥iOS不也用Weex来写呢？</p>
</blockquote>
<ul>
<li><p>回答0：身为iOS客户端开发，要对<code>Swift</code>语言有信仰！而且用<code>SwiftUI</code>来开发，同时能支持所有<code>Apple Platform</code>，不也挺香吗。</p>
</li>
<li><p>回答1：反正是个学习的项目，怎么折腾怎么来😏。  </p>
</li>
</ul>
<blockquote>
<p>为啥不用<code>Java</code>或者<code>Kotlin</code>来写Android呢？</p>
</blockquote>
<ul>
<li>有了<code>Swift</code>，谁还用<code>Java</code>和<code>Kotlin</code>啊😄。</li>
</ul>
<h2 id="Server-amp-数据库"><a href="#Server-amp-数据库" class="headerlink" title="Server &amp; 数据库"></a>Server &amp; 数据库</h2><p>后台用<code>Server-Side Swift</code>来写，参考<a href="https://github.com/vapor/vapor" target="_blank" rel="noopener">Vapor</a>。<br>数据抓取可能需要用到Python。<br>数据库继续使用MySQL。<br>服务器继续使用腾讯云。  </p>
<p>之前写后台都是用的非常成熟的 LNMP（Linux、Nginx、MySQL、PHP/Python/Perl）方案，而且都是些很简单的项目，比如APNS push服务、Bitwarden服务等，所以这次后台和数据库的部分挑战会比较大。不过好在服务器已经有了，而且能够直接使用<code>Swift</code>来写，好像也不会太折腾。</p>
<p>可能存在的坑就是<code>Server-Side Swift</code>还不成熟，配套的社区和插件会比较弱，不过作为学习项目，有啥用啥呗。</p>
<h2 id="计划"><a href="#计划" class="headerlink" title="计划"></a>计划</h2><p>啊，要做的东西太多了！还是一步步来吧，不能好高骛远。</p>
<ol>
<li>使用<code>SwiftUI</code>完成客户端基本UI</li>
<li>配置<code>Swift</code>服务端开发环境，跑通流程</li>
<li>使用<code>Python</code>抓取真实数据并存储</li>
<li>实现接入层逻辑，完成客户端和Server的交互</li>
<li>使用 <em>Weex</em> 编写Android端和Web端</li>
</ol>
<p>千里执行始于足下，无论是milestone还是stone砸出的大坑，都走着瞧吧！</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://blog.jerrychu.top/2020/10/21/Swizzle%E7%9A%84%E6%AD%A3%E7%A1%AE%E5%A7%BF%E5%8A%BF2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="JerryChu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="++">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/10/21/Swizzle%E7%9A%84%E6%AD%A3%E7%A1%AE%E5%A7%BF%E5%8A%BF2/" class="post-title-link" itemprop="url">Swizzle的正确姿势（二）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-10-21 19:02:55" itemprop="dateCreated datePublished" datetime="2020-10-21T19:02:55+08:00">2020-10-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-11-22 14:13:40" itemprop="dateModified" datetime="2020-11-22T14:13:40+08:00">2020-11-22</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>上一篇文章介绍了<a href="https://blog.jerrychu.top/2020/06/21/Swizzle%E7%9A%84%E6%AD%A3%E7%A1%AE%E5%A7%BF%E5%8A%BF/">Swizzle的错误姿势</a>，错误地使用Swizzle很容易引发一系列隐蔽的问题，那么我们该如何正确且优雅地进行Swizzle呢？</p>
<p>在错误的Swizzle方案中，为了修改方法的实现，我们会新增一个方法（<em>jy_viewDidLoad<em>），然后和原始方法(</em>viewDidLoad</em>)进行交换。这个新增的方法其实没有什么作用，只是为了提供一个新的实现而已。  </p>
<p>但是这个新增的方法却给代码带来了一系列的问题，比如<a href="https://blog.jerrychu.top/2020/06/21/Swizzle%E7%9A%84%E6%AD%A3%E7%A1%AE%E5%A7%BF%E5%8A%BF/">上一篇文章</a>提到的<code>_cmd</code>错误。那么能不能不新增这个方法呢？  </p>
<p>当然是可以的。</p>
<h2 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h2><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;objc/runtime.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;objc/message.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">IMP class_swizzleSelector(Class clazz, SEL selector, IMP newImplementation)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// If the method does not exist for this class, do nothing</span></span><br><span class="line">    Method method = class_getInstanceMethod(clazz, selector);</span><br><span class="line">    <span class="keyword">if</span> (! method) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Make sure the class implements the method. If this is not the case, inject an implementation, calling 'super'</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *types = method_getTypeEncoding(method);</span><br><span class="line">    class_addMethod(clazz, selector, imp_implementationWithBlock(^(__<span class="keyword">unsafe_unretained</span> <span class="keyword">id</span> <span class="keyword">self</span>, va_list argp) &#123;</span><br><span class="line">        <span class="keyword">struct</span> objc_super <span class="keyword">super</span> = &#123;</span><br><span class="line">            .receiver = <span class="keyword">self</span>,</span><br><span class="line">            .super_class = class_getSuperclass(clazz)</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">id</span> (*objc_msgSendSuper_typed)(<span class="keyword">struct</span> objc_super *, SEL, va_list) = (<span class="keyword">void</span> *)&amp;objc_msgSendSuper;</span><br><span class="line">        <span class="keyword">return</span> objc_msgSendSuper_typed(&amp;<span class="keyword">super</span>, selector, argp);</span><br><span class="line">    &#125;), types);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Can now safely swizzle</span></span><br><span class="line">    <span class="keyword">return</span> class_replaceMethod(clazz, selector, newImplementation, types);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过直接修改原有实现的方式，我们就可以做到不新增方法的Swizzle。  </p>
<p>好像看着也不复杂？但实际情况并没有这么简单。虽然OC中大多数的方法调用都是使用<code>objc_msgSend</code>，但是毕竟是由例外的。当方法返回值是较大的结构体时，此时返回值无法直接放入寄存器中，编译器会转而使用<code>objc_msgSend_stret</code>方法，将返回值直接放入栈中。<br>这种情况下，上面的方案就不适用了，我们需要继续针对<code>objc_msgSend_stret</code>方法进行处理。</p>
<h2 id="objc-msgSend-stret"><a href="#objc-msgSend-stret" class="headerlink" title="objc_msgSend_stret"></a>objc_msgSend_stret</h2><p>话不多说，直接上代码：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">IMP class_swizzleSelector_stret(Class clazz, SEL selector, IMP newImplementation)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// If the method does not exist for this class, do nothing</span></span><br><span class="line">    Method method = class_getInstanceMethod(clazz, selector);</span><br><span class="line">    <span class="keyword">if</span> (! method) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Make sure the class implements the method. If this is not the case, inject an implementation, only calling 'super'</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *types = method_getTypeEncoding(method);</span><br><span class="line">    class_addMethod(clazz, selector, imp_implementationWithBlock(^(__<span class="keyword">unsafe_unretained</span> <span class="keyword">id</span> <span class="keyword">self</span>, va_list argp) &#123;</span><br><span class="line">        <span class="keyword">struct</span> objc_super <span class="keyword">super</span> = &#123;</span><br><span class="line">            .receiver = <span class="keyword">self</span>,</span><br><span class="line">            .super_class = class_getSuperclass(clazz)</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Sufficiently large struct</span></span><br><span class="line">        <span class="keyword">typedef</span> <span class="keyword">struct</span> LargeStruct_ &#123;</span><br><span class="line">            <span class="keyword">char</span> dummy[<span class="number">16</span>];</span><br><span class="line">        &#125; LargeStruct;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Cast the call to objc_msgSendSuper_stret appropriately</span></span><br><span class="line">        LargeStruct (*objc_msgSendSuper_stret_typed)(<span class="keyword">struct</span> objc_super *, SEL, va_list) = (<span class="keyword">void</span> *)&amp;objc_msgSendSuper_stret;</span><br><span class="line">        <span class="keyword">return</span> objc_msgSendSuper_stret_typed(&amp;<span class="keyword">super</span>, selector, argp);</span><br><span class="line">    &#125;), types);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Can now safely swizzle</span></span><br><span class="line">    <span class="keyword">return</span> class_replaceMethod(clazz, selector, newImplementation, types);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种方案虽然比直接新增方法并替换麻烦了一些，但是可以做到不新增方法实现Swizzle，也就自然不会有<code>_cmd</code>错误的问题。  </p>
<p>这才是Swizzle的正确姿势！</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://pspdfkit.com/blog/2019/swizzling-in-swift/" target="_blank" rel="noopener">https://pspdfkit.com/blog/2019/swizzling-in-swift/</a></li>
<li><a href="http://defagos.github.io/yet_another_article_about_method_swizzling/" target="_blank" rel="noopener">http://defagos.github.io/yet_another_article_about_method_swizzling/</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://blog.jerrychu.top/2020/08/09/%E4%B8%AA%E4%BA%BA%E4%BB%A3%E7%A0%81%E8%A6%86%E7%9B%96%E7%8E%87%E7%BB%9F%E8%AE%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="JerryChu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="++">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/09/%E4%B8%AA%E4%BA%BA%E4%BB%A3%E7%A0%81%E8%A6%86%E7%9B%96%E7%8E%87%E7%BB%9F%E8%AE%A1/" class="post-title-link" itemprop="url">个人代码覆盖率统计</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-08-09 17:17:38 / Modified: 17:18:41" itemprop="dateCreated datePublished" datetime="2020-08-09T17:17:38+08:00">2020-08-09</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p> 建议先阅读<a href="https://blog.jerrychu.top/2020/05/23/iOS%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E6%95%B0%E6%8D%AE%E7%BB%9F%E8%AE%A1/">iOS单元测试数据统计</a> 和 <a href="https://blog.jerrychu.top/2020/05/23/iOS%E4%BB%A3%E7%A0%81%E8%A6%86%E7%9B%96%E7%8E%87%E7%BB%9F%E8%AE%A1/">iOS代码覆盖率统计</a>。</p>
</blockquote>
<p>本文涉及的所有脚本均托管在GitHub项目 <a href="https://github.com/JerryChu/UnitTestParser" target="_blank" rel="noopener">UnitTestParser</a> 中。<br>Demo工程：<a href="https://github.com/JerryChu/UnitTestDemo" target="_blank" rel="noopener">UnitTestDemo</a> </p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>之前文章介绍的<a href="https://blog.jerrychu.top/2020/05/23/iOS%E4%BB%A3%E7%A0%81%E8%A6%86%E7%9B%96%E7%8E%87%E7%BB%9F%E8%AE%A1/">项目代码覆盖率统计</a>和<a href="https://blog.jerrychu.top/2020/06/14/%E5%A2%9E%E9%87%8F%E4%BB%A3%E7%A0%81%E8%A6%86%E7%9B%96%E7%8E%87%E7%BB%9F%E8%AE%A1/">增量代码覆盖率统计</a>都是基于这个那个项目维度，统计项目整体的代码覆盖率和增量覆盖率的。有时候我们想要知道项目中每个成员提交的代码覆盖率数据，辅助我们去评估大家提交的代码质量如何，同时也激励大家写出更高质量的单元测试。  </p>
<h2 id="个人代码覆盖率"><a href="#个人代码覆盖率" class="headerlink" title="个人代码覆盖率"></a>个人代码覆盖率</h2><p>那么如何统计项目中所有代码提交者（committer）的代码覆盖率情况呢？首先我们得知道每一个committer到底提交了那些代码（精确到代码行），然后在此基础上确认这些代码行是否覆盖，最后计算得到代码覆盖率。</p>
<h3 id="代码行负责人"><a href="#代码行负责人" class="headerlink" title="代码行负责人"></a>代码行负责人</h3><p>我们知道在Xcode中点击代码编辑器右上角的 <em>Author</em> 按钮，就能够看到当前文件每一行代码的“负责人”，也就是谁最后增新增或者修改了这一行。这个功能是怎么实现的呢？其实就是基于<code>git blame</code>命令。</p>
<blockquote>
<p>git-blame - Show what revision and author last modified each line of a file</p>
</blockquote>
<p>（详细用法可以在命令行中输入<code>git blame</code>查看，或者参考<a href="https://git-scm.com/docs/git-blame" target="_blank" rel="noopener">官方文档</a>。）</p>
<p>比如在<a href="https://github.com/JerryChu/UnitTestDemo" target="_blank" rel="noopener">Demo项目</a>目录下命令行中执行：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">╰─± git blame -c --date=<span class="keyword">short</span> Demo/CDataUtil.h</span><br></pre></td></tr></table></figure>

<p>就能看到如下输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">9caa7b6b        (  jerrychu     2020-03-29      1)&#x2F;&#x2F;</span><br><span class="line">9caa7b6b        (  jerrychu     2020-03-29      2)&#x2F;&#x2F;  CDataUtil.h</span><br><span class="line">9caa7b6b        (  jerrychu     2020-03-29      3)&#x2F;&#x2F;  Demo</span><br><span class="line">9caa7b6b        (  jerrychu     2020-03-29      4)&#x2F;&#x2F;</span><br><span class="line">9caa7b6b        (  jerrychu     2020-03-29      5)&#x2F;&#x2F;  Created by JerryChu on 2019&#x2F;12&#x2F;15.</span><br><span class="line">9caa7b6b        (  jerrychu     2020-03-29      6)&#x2F;&#x2F;  Copyright © 2019 Chu. All rights reserved.</span><br><span class="line">9caa7b6b        (  jerrychu     2020-03-29      7)&#x2F;&#x2F;</span><br><span class="line">9caa7b6b        (  jerrychu     2020-03-29      8)</span><br><span class="line">9caa7b6b        (  jerrychu     2020-03-29      9)#import &lt;Foundation&#x2F;Foundation.h&gt;</span><br><span class="line">9caa7b6b        (  jerrychu     2020-03-29      10)</span><br><span class="line">9caa7b6b        (  jerrychu     2020-03-29      11)NS_ASSUME_NONNULL_BEGIN</span><br><span class="line">9caa7b6b        (  jerrychu     2020-03-29      12)</span><br><span class="line">9caa7b6b        (  jerrychu     2020-03-29      13)@interface CDataUtil : NSObject</span><br><span class="line">9caa7b6b        (  jerrychu     2020-03-29      14)</span><br><span class="line">9caa7b6b        (  jerrychu     2020-03-29      15)&#x2F;&#x2F;&#x2F; 将数字转化为字符串</span><br><span class="line">9caa7b6b        (  jerrychu     2020-03-29      16)&#x2F;&#x2F;&#x2F; @discussion 大于等于10万时，展示xx万，不带小数点</span><br><span class="line">9caa7b6b        (  jerrychu     2020-03-29      17)&#x2F;&#x2F;&#x2F; @discussion 大于等于1万时，展示1.x万，保留一位小数点</span><br><span class="line">9caa7b6b        (  jerrychu     2020-03-29      18)&#x2F;&#x2F;&#x2F; @discussion 低于1万时，展示实际数字</span><br><span class="line">9caa7b6b        (  jerrychu     2020-03-29      19)&#x2F;&#x2F;&#x2F; @param count 数字</span><br><span class="line">9caa7b6b        (  jerrychu     2020-03-29      20)+ (NSString *)descForCount:(NSInteger)count;</span><br><span class="line">9caa7b6b        (  jerrychu     2020-03-29      21)</span><br><span class="line">9caa7b6b        (  jerrychu     2020-03-29      22)&#x2F;&#x2F;&#x2F; 将数字转化为字符串</span><br><span class="line">9caa7b6b        (  jerrychu     2020-03-29      23)&#x2F;&#x2F;&#x2F; @discussion 大于等于10万时，展示xx万，不带小数点</span><br><span class="line">9caa7b6b        (  jerrychu     2020-03-29      24)&#x2F;&#x2F;&#x2F; @discussion 大于等于1万时，展示1.x万，保留一位小数点</span><br><span class="line">9caa7b6b        (  jerrychu     2020-03-29      25)&#x2F;&#x2F;&#x2F; @discussion 大于&#96;countThreshold&#96;时，展示实际数字</span><br><span class="line">9caa7b6b        (  jerrychu     2020-03-29      26)&#x2F;&#x2F;&#x2F; @discussion 小于等于&#96;countThreshold&#96;时，不展示</span><br><span class="line">9caa7b6b        (  jerrychu     2020-03-29      27)&#x2F;&#x2F;&#x2F; @param count 数字</span><br><span class="line">9caa7b6b        (  jerrychu     2020-03-29      28)+ (NSString *)descForCount2:(NSInteger)count;</span><br><span class="line">9caa7b6b        (  jerrychu     2020-03-29      29)</span><br><span class="line">7e08d03f        (jerrychu(褚佳义)       2020-05-01      30)&#x2F;&#x2F; 将threshold作为参数传入，避免内部产生依赖</span><br><span class="line">7e08d03f        (jerrychu(褚佳义)       2020-05-01      31)+ (NSString *)descForCount2:(NSInteger)count withThreshold:(NSInteger)threshold;</span><br><span class="line">7e08d03f        (jerrychu(褚佳义)       2020-05-01      32)</span><br><span class="line">9caa7b6b        (  jerrychu     2020-03-29      33)@end</span><br><span class="line">9caa7b6b        (  jerrychu     2020-03-29      34)</span><br><span class="line">9caa7b6b        (  jerrychu     2020-03-29      35)NS_ASSUME_NONNULL_END</span><br></pre></td></tr></table></figure>

<p>既然通过<code>git blame</code>命令就能找到项目中的每一行的代码负责人，那接下来的具体步骤就很清晰了。   </p>
<h3 id="具体步骤"><a href="#具体步骤" class="headerlink" title="具体步骤"></a>具体步骤</h3><ol>
<li>遍历所有文件，获取每个committer负责所有代码行。</li>
<li>遍历其负责的代码行数据，确定代码行是否被覆盖。</li>
<li>对每个committer分别统计代码覆盖率。</li>
</ol>
<p>第一步通过对<code>git blame</code>命令的输出结果进行解析和统计，就可以得到。<br>第二步可以直接参考之前的<a href="https://blog.jerrychu.top/2020/06/14/%E5%A2%9E%E9%87%8F%E4%BB%A3%E7%A0%81%E8%A6%86%E7%9B%96%E7%8E%87%E7%BB%9F%E8%AE%A1/">增量代码覆盖率统计</a>文章，里面详细得介绍了如何判断代码行是否被覆盖，原理是一样的。<br>第三步就是单纯的计算了，没啥可说的，写出来主要是为了分三步走。  </p>
<h3 id="脚本实现"><a href="#脚本实现" class="headerlink" title="脚本实现"></a>脚本实现</h3><p><a href="https://github.com/JerryChu/UnitTestParser" target="_blank" rel="noopener">UnitTestParser</a>项目提供了 <a href="https://github.com/JerryChu/UnitTestParser/blob/master/userCov.rb" target="_blank" rel="noopener"><em>userCov.rb</em></a> 脚本来实现个人代码覆盖率的解析和输出。</p>
<p>例如执行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">╰─± ruby ..&#x2F;UnitTestParser&#x2F;userCov.rb --xcresult-path&#x3D;test.xcresult --output-file&#x3D;userCov.html --proj-dir&#x3D;.&#x2F;</span><br></pre></td></tr></table></figure>

<p>则会生成如下的html</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">代码覆盖率（from 1970-01-01 to 2020-08-09）</span><br><span class="line">开发者	增加/修改代码行数	覆盖代码行数	覆盖率</span><br><span class="line">jerrychu	154	            130 	0.84</span><br></pre></td></tr></table></figure>

<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ol>
<li><p>脚本中使用的 <em>test.xcresult</em> 文件为我本地生成的结果文件，大家使用Demo项目测试该命令之前，需要先在自己机器上重新生成一份 <em>test.xcresult</em> 文件，否则会由于路径不匹配导致无法获取结果数据。  </p>
<p> 如何生成 <em>test.xcresult</em> 文件呢？之前的文章都已经提到过，这里再复习一遍。</p>
 <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> <span class="keyword">for</span> xcodeproj</span></span><br><span class="line">xcodebuild test -project Demo.xcodeproj -scheme Demo -derivedDataPath "$&#123;BUILD_DIR&#125;/" -destination "$&#123;SIMULATOR_PLATFORM&#125;" -resultBundlePath "$&#123;XCRESULT_PATH&#125;" -resultBundleVersion 3</span><br></pre></td></tr></table></figure>
</li>
<li><p>脚本中需要设置开发人员名单，不在名单内的数据将不会被统计进去。</p>
 <figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 要统计的开发者列表</span></span><br><span class="line">$developer_list = [<span class="string">"jerrychu"</span>]</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="个人新增代码覆盖率"><a href="#个人新增代码覆盖率" class="headerlink" title="个人新增代码覆盖率"></a>个人新增代码覆盖率</h2><p>如果详细看了 <em>userCov.rb</em> 脚本的话，大家会发现脚本执行参数中有一个 <em>begin_date</em> 选项，用于指定从什么时间点开始统计。</p>
<p>为什么要加这样一个参数呢？我们在统计每个committer的代码覆盖率时，更希望看到最近一段时间（比如当前版本的开始时间）内每个committer提交的代码的覆盖率情况。而<code>git blame</code>会把项目中每一个代码行都展示出来，但是其中很多是历史代码，参考意义不大。</p>
<p>附：<code>git blame</code> 也提供一些参数用来设置时间区间或commit区间，但是并不符合我们这里的统计需求，有兴趣的可以在命令行中执行<code>git help blame</code>看下。</p>
<p>设置 <em>begin_date</em> 选项之后，脚本里在解析<code>git blame</code>结果时，就会将这个时间点之前的代码行都过滤掉，只统计这个时间点之后新增或修改的代码行。在实际应用中，我们可以把这个参数设置为版本开始的时间，用来统计从版本开始到现在，大家提交代码的覆盖率情况。</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 根据git blame统计begin_date时间之后每个人修改过的文件及行数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">user_files_map</span><span class="params">(proj_dir, begin_date)</span></span></span><br></pre></td></tr></table></figure>

<p>在执行脚本时增加 <em>begin-date</em> 参数即可统计到该时间点之后的committer新增代码覆盖率情况。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">╰─± ruby ..&#x2F;UnitTestParser&#x2F;userCov.rb --xcresult-path&#x3D;test.xcresult --proj-dir&#x3D;.&#x2F; --output-file&#x3D;userCov.html --begin-date&#x3D;&quot;2019-10-18&quot;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>个人代码覆盖率的统计对提升每个项目成员的单元测试水平和整体单元测试水平都有重要的作用。<br><a href="https://github.com/JerryChu/UnitTestParser" target="_blank" rel="noopener">UnitTestParser</a>项目提供的脚本可以快速准确地解析出项目中每个人的代码覆盖率，以及每个人的增量代码覆盖率，并且可以做到自动化统计。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://blog.jerrychu.top/2020/06/21/Swizzle%E7%9A%84%E6%AD%A3%E7%A1%AE%E5%A7%BF%E5%8A%BF/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="JerryChu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="++">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/21/Swizzle%E7%9A%84%E6%AD%A3%E7%A1%AE%E5%A7%BF%E5%8A%BF/" class="post-title-link" itemprop="url">Swizzle的正确姿势（一）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-06-21 19:02:55 / Modified: 21:25:23" itemprop="dateCreated datePublished" datetime="2020-06-21T19:02:55+08:00">2020-06-21</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="常见Swizzle方案"><a href="#常见Swizzle方案" class="headerlink" title="常见Swizzle方案"></a>常见Swizzle方案</h2><p>在OC里如何实现Swizzle？相信大家经过一番Google之后很容易就能实现。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">BOOL</span> JYReplaceMethodWithBlock(Class c, SEL origSEL, SEL newSEL, <span class="keyword">id</span> block) &#123;</span><br><span class="line"></span><br><span class="line">    Method origMethod = class_getInstanceMethod(c, origSEL);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 添加newSEL及对应的实现</span></span><br><span class="line">    IMP newIMP = imp_implementationWithBlock(block);</span><br><span class="line">    <span class="keyword">if</span> (!class_addMethod(c, newSEL, newIMP, method_getTypeEncoding(origMethod))) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    Method newMethod = class_getInstanceMethod(c, newSEL);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (class_addMethod(c, origSEL, newIMP, method_getTypeEncoding(origMethod))) &#123;</span><br><span class="line">        <span class="comment">// 没有origSEL，添加origSEL，使用新实现</span></span><br><span class="line">        <span class="comment">// 同时将newSEL替换为旧实现</span></span><br><span class="line">        class_replaceMethod(c, newSEL, method_getImplementation(origMethod), method_getTypeEncoding(origMethod));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 已经有origSEL，直接交换实现</span></span><br><span class="line">        method_exchangeImplementations(origMethod, newMethod);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面就是一个初步的Swizzle方案，重点在最后一部分：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">if (class_addMethod(c, origSEL, newIMP, method_getTypeEncoding(origMethod))) &#123;</span><br><span class="line">    &#x2F;&#x2F; 没有origSEL，添加origSEL，使用新实现</span><br><span class="line">    &#x2F;&#x2F; 同时将newSEL替换为旧实现</span><br><span class="line">    class_replaceMethod(c, newSEL, method_getImplementation(origMethod), method_getTypeEncoding(origMethod));</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    &#x2F;&#x2F; 已经有origSEL，直接交换实现</span><br><span class="line">    method_exchangeImplementations(origMethod, newMethod);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里主要做的事情就是将 <em>origSEL</em> 和 <em>newSEL</em> 的实现进行交换。交换之后，在调用 <em>origSEL</em> 方法时，就会走到我们的自定义实现，也就完成了Swizzle。  </p>
<p>比如我们想要Swizzle掉 ViewController 类的 <em>viewDidLoad</em> 方法，直接添加下面的代码即可。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SEL newSEL = <span class="built_in">NSSelectorFromString</span>(<span class="string">@"jy_viewDidLoad"</span>);</span><br><span class="line">JYReplaceMethodWithBlock([ViewController <span class="keyword">class</span>], <span class="keyword">@selector</span>(viewDidLoad), newSEL, ^(ViewController *_<span class="keyword">self</span>)&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"swizzled"</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>添加之后，ViewController 类原始的 <em>viewDidLoad</em> 方法就会被新的 <em>jy_viewDidLoad</em> 方法替换掉。因此在调用 <em>viewDidLoad</em> 方法时，实际执行的内容已经变成自定义的是实现了，即 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSLog(@&quot;swizzled&quot;);</span><br></pre></td></tr></table></figure>

<h2 id="原始方法调用"><a href="#原始方法调用" class="headerlink" title="原始方法调用"></a>原始方法调用</h2><p>如果我们只是想插入一段自定义的代码，执行完之后还是想走原始的实现怎么办呢？我们先来看下现在的<code>SEL</code>和<code>IMP</code>的对应关系。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">viewDidLoad --&gt; 新的实现</span><br><span class="line">jy_viewDidLoad --&gt; 原始viewDidLoad的实现</span><br></pre></td></tr></table></figure>

<p>可以看到，现在 <em>jy_viewDidLoad</em> 对应的就是原始的实现，直接调用该方法就行了。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SEL newSEL = <span class="built_in">NSSelectorFromString</span>(<span class="string">@"jy_viewDidLoad"</span>);</span><br><span class="line">JYReplaceMethodWithBlock([ViewController <span class="keyword">class</span>], <span class="keyword">@selector</span>(viewDidLoad), newSEL, ^(ViewController *_<span class="keyword">self</span>)&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"swizzled"</span>);</span><br><span class="line">    ((<span class="keyword">void</span> (*)(<span class="keyword">id</span>, SEL))objc_msgSend)(_<span class="keyword">self</span>, newSEL);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>这样就实现了插入自定义代码后继续执行原始逻辑。  </p>
<p>非常简单是不是？一般情况下我们使用上面的Swizzle方案不会遇到什么问题，但是它实际是有漏洞的，可能会造成令人崩溃的bug。</p>
<h2 id="Swizzle带来的问题"><a href="#Swizzle带来的问题" class="headerlink" title="Swizzle带来的问题"></a>Swizzle带来的问题</h2><p>我们在ViewController类的 <em>viewDidLoad</em> 方法中加一句log，看下当前的 <code>_cmd</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    NSLog(@&quot;%@&quot;, NSStringFromSelector(_cmd));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行之后，输出如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2020-06-21 19:36:44:675767+8000 Demo[14146:9871258] jy_viewDidLoad</span><br></pre></td></tr></table></figure>

<p>怎么回事？我们明明是在 <em>viewDidLoad</em> 方法中打印的 <code>_cmd</code>，怎么就变成了 <em>jy_viewDidLoad</em> 呢？  </p>
<p>为了解释这个问题，我们再复习一下Swizzle代码以及<code>SEL</code>和<code>IMP</code>的对应关系：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SEL newSEL = <span class="built_in">NSSelectorFromString</span>(<span class="string">@"jy_viewDidLoad"</span>);</span><br><span class="line">JYReplaceMethodWithBlock([ViewController <span class="keyword">class</span>], <span class="keyword">@selector</span>(viewDidLoad), newSEL, ^(ViewController *_<span class="keyword">self</span>)&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"swizzled"</span>);</span><br><span class="line">    ((<span class="keyword">void</span> (*)(<span class="keyword">id</span>, SEL))objc_msgSend)(_<span class="keyword">self</span>, newSEL);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">viewDidLoad --&gt; 新的实现</span><br><span class="line">jy_viewDidLoad --&gt; 原始viewDidLoad的实现</span><br></pre></td></tr></table></figure>

<p>看到什么了？实际调用 <em>viewDidLoad</em> 方法时，会走到我们自定义的实现，也就是 <code>NSLog(@&quot;swizzled&quot;);</code> 那段代码，在NSLog之后我们又调用了原始的实现，因为 <em>jy_viewDidLoad</em> 对应的原始的实现，所以调用代码为 <code>((void (*)(id, SEL))objc_msgSend)(_self, newSEL);</code>。 所以在执行原始实现时，<strong><code>_cmd</code> 变成 <em>jy_viewDidLoad</em> 了</strong>。</p>
<p>在本文被的例子中，这个问题可能并不严重，因为并没有基于 <code>_cmd</code> 做任何的逻辑。但是在实际场景中，很有可能有方法使用了 <code>_cmd</code>，比如UIKit中的touch转发：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (void)touchesMoved:(NSSet *)touches withEvent:(UIEvent *)event &#123;</span><br><span class="line">    forwardTouchMethod(self, _cmd, touches, event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果我们Swizzle了 <em>touchesMoved:withEvent:</em> 方法，由于 <code>_cmd</code> 发生了变化，实际运行时 <em>forwardTouchMethod</em> 方法内部会找不到这个方法，导致出现crash。</p>
<h2 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h2><p>这种Swizzle方法除了会改变 <code>_cmd</code> 之外，也会有一些其他问题，比如同时Swizzle了父类和子类的方法，会导致方法的执行不会按照继承关系走，进而出现一系列奇怪的问题。具体可以参考 <a href="http://defagos.github.io/yet_another_article_about_method_swizzling/" target="_blank" rel="noopener">http://defagos.github.io/yet_another_article_about_method_swizzling/</a>，本文就不再赘述。</p>
<h2 id="更优雅的Swizzle方案"><a href="#更优雅的Swizzle方案" class="headerlink" title="更优雅的Swizzle方案"></a>更优雅的Swizzle方案</h2><p>那么该怎么实现Swizzle才不会有上面的问题呢？Swizzle的正确姿势究竟是啥样的？且待下文分解。<br>（上面的文章链接中实际已经有答案了，着急的可以直接看～）</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://pspdfkit.com/blog/2019/swizzling-in-swift/" target="_blank" rel="noopener">https://pspdfkit.com/blog/2019/swizzling-in-swift/</a></li>
<li><a href="http://defagos.github.io/yet_another_article_about_method_swizzling/" target="_blank" rel="noopener">http://defagos.github.io/yet_another_article_about_method_swizzling/</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://blog.jerrychu.top/2020/06/14/%E5%A2%9E%E9%87%8F%E4%BB%A3%E7%A0%81%E8%A6%86%E7%9B%96%E7%8E%87%E7%BB%9F%E8%AE%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="JerryChu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="++">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/14/%E5%A2%9E%E9%87%8F%E4%BB%A3%E7%A0%81%E8%A6%86%E7%9B%96%E7%8E%87%E7%BB%9F%E8%AE%A1/" class="post-title-link" itemprop="url">增量代码覆盖率统计</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-06-14 16:19:41 / Modified: 16:28:24" itemprop="dateCreated datePublished" datetime="2020-06-14T16:19:41+08:00">2020-06-14</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p> 建议先阅读<a href="https://blog.jerrychu.top/2020/05/23/iOS%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E6%95%B0%E6%8D%AE%E7%BB%9F%E8%AE%A1/">iOS单元测试数据统计</a> 和 <a href="https://blog.jerrychu.top/2020/05/23/iOS%E4%BB%A3%E7%A0%81%E8%A6%86%E7%9B%96%E7%8E%87%E7%BB%9F%E8%AE%A1/">iOS代码覆盖率统计</a>。</p>
</blockquote>
<p>本文涉及的所有脚本均托管在GitHub项目 <a href="https://github.com/JerryChu/UnitTestParser" target="_blank" rel="noopener">UnitTestParser</a> 中。<br>Demo工程：<a href="https://github.com/JerryChu/UnitTestDemo" target="_blank" rel="noopener">UnitTestDemo</a> </p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><code>增量代码覆盖率</code>指的就是新增代码的代码覆盖率，也就是新增代码中有多少代码被单元测试覆盖了。我们可以通过如下公式计算增量代码覆盖率</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">deltaCov &#x3D; coveredDeltaLineCount &#x2F; deltaLineCount</span><br></pre></td></tr></table></figure>

<p>其中，<em>deltaLineCount</em> 指的是新增代码中的<strong>有效代码行数</strong>，<em>coveredDeltaLineCount</em> 指的是新增代码的有效代码行中，被单元测试覆盖的行数。用后者除以前者，就得到了本次新增代码的覆盖率，也就是增量代码覆盖率。</p>
<h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>增量代码覆盖率可以保证增量代码的单元测试水平，从而保证整体单元测试水平不断提升。一般情况下，我们会在如下几个场景统计增量代码覆盖率： </p>
<ul>
<li>有新的 PR（Pull Request）或 MR（Merge Request）时，检测本次PR/MR的增量代码覆盖率，决定是否合入。</li>
<li>检测不同版本之间的增量代码覆盖率，评估每个版本的增量代码单元测试水平。</li>
<li>定时检测每天的增量代码覆盖率，保证代码单元测试水平不断提升。</li>
</ul>
<p>增量代码覆盖率可以很好地体现新增代码的单元测试水平，有了增量代码覆盖率数据支撑之后，我们才能站在更高维度上把控项目代码的整体单元测试水平，提升代码覆盖率。</p>
<h2 id="增量覆盖率计算"><a href="#增量覆盖率计算" class="headerlink" title="增量覆盖率计算"></a>增量覆盖率计算</h2><p>我们再回到增量代码覆盖率的计算公式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">deltaCov &#x3D; coveredDeltaLineCount &#x2F; deltaLineCount</span><br></pre></td></tr></table></figure>

<p>我们已经知道，<em>deltaLineCount</em> 指的是新增代码中的有效代码行数，<em>coveredDeltaLineCount</em> 指的是新增代码的有效代码行中，被单元测试覆盖的行数。  </p>
<p>所以如果想计算增量代码覆盖率，我们需要分三步走：</p>
<ol>
<li>找到新增了哪些文件的那些代码行</li>
<li>获取单个文件的代码覆盖率报告，确定每一行的覆盖情况</li>
<li>确定新增的代码行是否被单元测试覆盖</li>
</ol>
<p>下面就按这3步来各个击破。  </p>
<h3 id="1-新增代码统计"><a href="#1-新增代码统计" class="headerlink" title="1. 新增代码统计"></a>1. 新增代码统计</h3><p>怎么去找到本次提交/MR修改了哪些文件的那些代码行呢？  </p>
<p>如果大家看过了<a href="https://blog.jerrychu.top/2020/06/07/%E8%8E%B7%E5%8F%96git%E5%A2%9E%E9%87%8F%E4%BB%A3%E7%A0%81%E6%95%B0%E6%8D%AE/">获取git增量代码数据</a>这篇文章的话，相信这不会是个问题。通过解析<code>git diff</code>的数据，我们就能够获取到<br>增量代码文件以及对应的代码行。  </p>
<h3 id="2-单个文件覆盖率报告"><a href="#2-单个文件覆盖率报告" class="headerlink" title="2. 单个文件覆盖率报告"></a>2. 单个文件覆盖率报告</h3><p>通过新增代码统计获取到所有新增的文件之后，我们需要对每个文件进行单独的处理，确定这个文件的每一行是否被覆盖。因此，我们必须能够获取单个文件的代码覆盖率报告。  </p>
<p>以<a href="https://github.com/JerryChu/UnitTestDemo" target="_blank" rel="noopener">UnitTestDemo</a>项目为例，使用如下命令就可以从 <em>.xcresult</em> 文件中获取到单个文件的代码覆盖率情况，其中包括了每一个代码行被单元测试执行的次数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># &#x2F;path&#x2F;to&#x2F;file 为执行单元测试时文件的绝对地址</span><br><span class="line">xcrun xccov view --archive --file &#x2F;path&#x2F;to&#x2F;file &#x2F;path&#x2F;to&#x2F;xcresult_file</span><br></pre></td></tr></table></figure>

<p>上面命令的输出结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"> 1: *</span><br><span class="line"> 2: *</span><br><span class="line"> 3: *</span><br><span class="line"> 4: *</span><br><span class="line"> 5: *</span><br><span class="line"> 6: *</span><br><span class="line"> 7: *</span><br><span class="line"> 8: *</span><br><span class="line"> 9: *</span><br><span class="line">10: *</span><br><span class="line">11: *</span><br><span class="line">12: *</span><br><span class="line">13: *</span><br><span class="line">14: *</span><br><span class="line">15: *</span><br><span class="line">16: *</span><br><span class="line">17: *</span><br><span class="line">18: *</span><br><span class="line">19: 10</span><br><span class="line">20: 10</span><br><span class="line">21: 10 [</span><br><span class="line">(24, 0, 1)</span><br><span class="line">]</span><br><span class="line">22: 1</span><br><span class="line">23: 9 [</span><br><span class="line">(1, 5, 1)</span><br><span class="line">(30, 0, 2)</span><br><span class="line">]</span><br><span class="line">24: 2</span><br><span class="line">25: 7 [</span><br><span class="line">(1, 5, 2)</span><br><span class="line">]</span><br><span class="line">26: 7</span><br><span class="line">27: 7 [</span><br><span class="line">(6, 0, 10)</span><br><span class="line">]</span><br><span class="line">28: 10</span><br><span class="line">29: 10</span><br><span class="line">30: *</span><br><span class="line">31: *</span><br><span class="line">32: *</span><br><span class="line">33: *</span><br><span class="line">34: *</span><br><span class="line">35: *</span><br><span class="line">36: *</span><br><span class="line">37: 1</span><br><span class="line">38: 1</span><br><span class="line">39: 1 [</span><br><span class="line">(24, 0, 0)</span><br><span class="line">]</span><br><span class="line">40: 0</span><br><span class="line">41: 1 [</span><br><span class="line">(1, 5, 0)</span><br><span class="line">(30, 0, 0)</span><br><span class="line">]</span><br><span class="line">42: 0</span><br><span class="line">43: 1 [</span><br><span class="line">(1, 5, 0)</span><br><span class="line">]</span><br><span class="line">44: 1</span><br><span class="line">45: 1 [</span><br><span class="line">(12, 0, 0)</span><br><span class="line">]</span><br><span class="line">46: 0</span><br><span class="line">47: 0 [</span><br><span class="line">(6, 0, 1)</span><br><span class="line">]</span><br><span class="line">48: 1</span><br><span class="line">49: 1</span><br><span class="line">50: *</span><br><span class="line">51: *</span><br><span class="line">52: *</span><br><span class="line">53: 0</span><br><span class="line">54: 0</span><br><span class="line">55: 0</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果输出报错，先通过<code>xcrun xccov view --archive --file-list test.xcresult</code>命令查看填写的文件路径是否正确。</p>
</blockquote>
<p>左侧的索引就是文件的代码行索引，右侧的数字表示的是该行在单元测试中被执行的次数，其中 <code>*</code> 表示该行不是可执行代码行，比如空白行等，在进行覆盖率计算时，这些行不会被当成有效代码行，也就不会被统计进去。 </p>
<blockquote>
<p>相信看到这里大家就知道增量覆盖率计算公式中的<strong>有效代码行</strong>是什么意思了。</p>
</blockquote>
<h3 id="3-确定新增代码行是否被覆盖"><a href="#3-确定新增代码行是否被覆盖" class="headerlink" title="3. 确定新增代码行是否被覆盖"></a>3. 确定新增代码行是否被覆盖</h3><p>通过上面的两步，我们就拿到了本次修改的文件及代码行，及每一个代码行是否被单元测试覆盖。接下来我们只需要针对每个文件逐行去解析即可。统计规则如下：</p>
<ul>
<li>新增可执行代码行：行索引后面不为<code>*</code></li>
<li>被覆盖的新增可执行代码行：行索引后面不为<code>*</code>，且数字大于0</li>
</ul>
<p><a href="https://github.com/JerryChu/UnitTestParser" target="_blank" rel="noopener">UnitTestParser</a>项目提供了 <a href="https://github.com/JerryChu/UnitTestParser/blob/master/deltaCov.rb" target="_blank" rel="noopener"><em>deltaCov.rb</em></a> 脚本来实现增量代码覆盖率的解析和输出。</p>
<p>例如执行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">╰─± ruby deltaCov.rb --xcresult-path&#x3D;path&#x2F;to&#x2F;xcresult_file --proj-dir&#x3D;.&#x2F; --diff-file&#x3D;path&#x2F;to&#x2F;diff_file --output-file&#x3D;deltaCov.txt</span><br></pre></td></tr></table></figure>

<p>则会输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">新增代码覆盖率：1.0</span><br><span class="line">新增可执行代码行数：11</span><br><span class="line">被覆盖的新增可执行代码行数：11</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果输出报错，先通过<code>xcrun xccov view --archive --file-list test.xcresult</code>命令查看填写的文件路径是否正确。</p>
</blockquote>
<p>同时这些数据也会被写入到 <em>deltaCov.txt</em> 文件中，便于其他工具读取。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">╰─± cat deltaCov.txt</span><br><span class="line">1.0</span><br><span class="line">11</span><br><span class="line">11</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><a href="https://github.com/JerryChu/UnitTestParser" target="_blank" rel="noopener">UnitTestParser</a>项目提供的脚本可以快速准确地解析出增量代码行数和增量代码覆盖行数，进而计算出增量代码覆盖率。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://blog.jerrychu.top/2020/06/07/%E8%8E%B7%E5%8F%96git%E5%A2%9E%E9%87%8F%E4%BB%A3%E7%A0%81%E6%95%B0%E6%8D%AE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="JerryChu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="++">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/07/%E8%8E%B7%E5%8F%96git%E5%A2%9E%E9%87%8F%E4%BB%A3%E7%A0%81%E6%95%B0%E6%8D%AE/" class="post-title-link" itemprop="url">获取git增量代码数据</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-06-07 21:48:33" itemprop="dateCreated datePublished" datetime="2020-06-07T21:48:33+08:00">2020-06-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-06-14 16:21:51" itemprop="dateModified" datetime="2020-06-14T16:21:51+08:00">2020-06-14</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>为了统计增量代码覆盖率，首先要获取增量代码，本文介绍如何快速准确地获取增量代码数据。</p>
</blockquote>
<h2 id="获取代码diff"><a href="#获取代码diff" class="headerlink" title="获取代码diff"></a>获取代码diff</h2><h3 id="git-diff-输出分析"><a href="#git-diff-输出分析" class="headerlink" title="git diff 输出分析"></a>git diff 输出分析</h3><p>相信大家都会使用<code>git diff</code>命令获取代码diff，比如在<a href="https://github.com/JerryChu/UnitTestDemo" target="_blank" rel="noopener">UnitTestDemo项目</a>中执行：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git diff e53b8299 a25e1cc3</span><br></pre></td></tr></table></figure>

<p>将会获得如下的输出：</p>
<p><img src="https://raw.githubusercontent.com/JerryChu/UnitTestParser/master/docs/diff.png" alt="diff结果"></p>
<p>其中，<code>-</code>表示删除的行，<code>+</code>表示新增的行（修改其实就是删除+新增）；<code>@@ -30,8 +30,8 @@</code> 表示删除了原先从第30行开始的8行，新增了从第30行开始的8行。</p>
<p>从上面的diff结果中可以获取到如下信息：</p>
<ul>
<li><em>targetCoverage.md</em> 文件发生了变更</li>
<li><em>targetCoverage.md</em> 从第30行到第37行，是本次变更的代码行。</li>
</ul>
<h3 id="diff数据优化"><a href="#diff数据优化" class="headerlink" title="diff数据优化"></a>diff数据优化</h3><p>但是 <em>targetCoverage.md</em> 文件只修改了4行代码（上图的红色/绿色部分），为什么diff结果说修改了8行呢？ </p>
<p>实际上，出于对<strong>效率</strong>的考虑（同时也考虑了merge的准确性等），git在做diff时并不是逐行做比较的，而是默认以<strong>3行</strong>作为一个<em>对比单元</em>，只要对比单元内有数据发生了变更，就认为这个单元是发生了变更的。所以我们看到虽然只修改了4行，<code>git diff</code>的结果却说有8行发生了变更。至于为什么在这次diff下是8行，大家可以再思考一下。    </p>
<p>虽然<code>git diff</code>的这个默认行为不会影响到diff的展示（我们可以看到上图红色/绿色部分确实是4行），但是却会对我们统计新增/修改代码行造成困扰。比如这次只修改了4行，但是<code>git diff</code>说有8行变更，导致统计到的数据<strong>偏大</strong>。  </p>
<p>如何解决这个问题呢？需要进一步对<code>git diff</code>进行深入研究。</p>
<p>从<code>git diff</code> 的帮助文档中可以看到一个有意思的参数：  </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-U&lt;n&gt;</span><br><span class="line">--unified=&lt;n&gt;</span><br><span class="line">Generate diffs with &lt;n&gt; lines of context instead of the usual three. Implies --patch. Implies -p.</span><br></pre></td></tr></table></figure>

<p>也就是说，我们可以通过设置 <em>unified</em> 的值，来修改 <code>git diff</code> 的默认行为。尝试再命令行中执行：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git diff e53b8299 a25e1cc3 --unified=0</span><br></pre></td></tr></table></figure>


<p>将会获得如下的输出：</p>
<p><img src="https://raw.githubusercontent.com/JerryChu/UnitTestParser/master/docs/diff1.png" alt="diff结果"></p>
<p>可以看到，加上<code>--unified=0</code>之后，<code>git diff</code>的新增/修改行数统计就是准确的了。  </p>
<h2 id="解析diff数据"><a href="#解析diff数据" class="headerlink" title="解析diff数据"></a>解析diff数据</h2><p>拿到准确的diff数据之后，我们还需要把<code>git diff</code>输出的数据转化为代码可以读取的数据。对于增量代码统计，我们希望获取到如下数据：</p>
<ul>
<li>所有变更文件的文件名</li>
<li>每个变更文件对应的的所有变更代码行</li>
</ul>
<p>其实<code>git diff</code>输出的结果中已经包含了这两份数据，我们要做的就是从输出的结果中解析出这些数据。   </p>
<p>本项目提供 <a href="https://github.com/JerryChu/UnitTestParser/blob/master/utils/diffParser.rb" target="_blank" rel="noopener"><em>diffParser.rb</em></a> 用于从<code>git diff</code>的输出结果中解析出最终需要的数据。  </p>
<p>在命令行中执行</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git diff e53b8299 a25e1cc3 --unified=0 &gt; a.diff</span><br><span class="line"></span><br><span class="line">ruby utils/diffParser.rb --diff-file=a.diff</span><br></pre></td></tr></table></figure>

<p>就会获得如下的数据</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;"docs/targetCoverage.md"=&gt;[33, 34, 35, 36]&#125;</span><br></pre></td></tr></table></figure>

<p>其中，<em>key</em> 为所有发生变更的文件名，<em>value</em> 为该文件对应的变更代码行（新增/修改的代码行）。  </p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过使用<code>git diff</code>命令，并对输出结果进行自定义的解析，我们就可以很容易地获取到新增代码数据了。下一篇文章会继续介绍如何在已经有了增量代码数据的基础上仅一步统计增量代码覆盖率。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://blog.jerrychu.top/2020/05/23/iOS%E4%BB%A3%E7%A0%81%E8%A6%86%E7%9B%96%E7%8E%87%E7%BB%9F%E8%AE%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="JerryChu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="++">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/23/iOS%E4%BB%A3%E7%A0%81%E8%A6%86%E7%9B%96%E7%8E%87%E7%BB%9F%E8%AE%A1/" class="post-title-link" itemprop="url">iOS代码覆盖率统计</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-05-23 23:33:45 / Modified: 23:41:30" itemprop="dateCreated datePublished" datetime="2020-05-23T23:33:45+08:00">2020-05-23</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p> 建议先阅读<a href="http://localhost:4000/2020/05/23/iOS%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E6%95%B0%E6%8D%AE%E7%BB%9F%E8%AE%A1/" target="_blank" rel="noopener">iOS单元测试自动化 – 单元测试数据统计</a>。</p>
</blockquote>
<p>本文涉及的所有脚本均托管在GitHub项目 <a href="https://github.com/JerryChu/UnitTestParser" target="_blank" rel="noopener">UnitTestParser</a> 中。<br>Demo工程：<a href="https://github.com/JerryChu/UnitTestDemo" target="_blank" rel="noopener">UnitTestDemo</a> </p>
<p>统计整体代码覆盖率以及各个target的代码覆盖率数据。</p>
<h2 id="解析代码覆盖率文件"><a href="#解析代码覆盖率文件" class="headerlink" title="解析代码覆盖率文件"></a>解析代码覆盖率文件</h2><p>使用苹果官方提供的命令行工具<code>xccov</code>即可完成代码覆盖率的解析，并且可以获取到整体的代码覆盖率及各个模块的代码覆盖率。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xcrun xccov view --report --json #&#123;xcresult_path&#125; &gt; #&#123;json_path&#125;</span><br></pre></td></tr></table></figure>

<p>拿到json文件后，就可以通过解析json文件来获取代码覆盖率。<br><a href="https://github.com/JerryChu/UnitTestParser" target="_blank" rel="noopener">UnitTestParser</a>项目提供 <a href="https://github.com/JerryChu/UnitTestParser/blob/master/targetCoverage.rb" target="_blank" rel="noopener"><em>target.rb</em></a> 来解析整体代码覆盖率和分模块的代码覆盖率。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 传入文件为使用&#96;xccov&#96;解析之后的json文件</span><br><span class="line">ruby targetCoverage.rb --cov-json-path&#x3D;path&#x2F;to&#x2F;json_file --output-file&#x3D;path&#x2F;to&#x2F;output_file</span><br></pre></td></tr></table></figure>

<p>例如执行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">╰─± ruby targetCoverage.rb --cov-json-path&#x3D;result.json --output-file&#x3D;result.html</span><br></pre></td></tr></table></figure>

<p>我们就可以得到如下的结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">target	        可执行代码行数 覆盖代码行数  代码覆盖率</span><br><span class="line">All                 424         313       73.8%</span><br><span class="line">DemoTests.xctest    223         217       97.3%</span><br><span class="line">Demo.app            201         96        47.7%</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://blog.jerrychu.top/2020/05/23/iOS%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E6%95%B0%E6%8D%AE%E7%BB%9F%E8%AE%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="JerryChu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="++">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/23/iOS%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E6%95%B0%E6%8D%AE%E7%BB%9F%E8%AE%A1/" class="post-title-link" itemprop="url">iOS单元测试数据统计</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-05-23 22:00:51 / Modified: 23:42:51" itemprop="dateCreated datePublished" datetime="2020-05-23T22:00:51+08:00">2020-05-23</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><blockquote>
<p>苹果在<strong>Xcode11</strong>版本中对单元测试结果文件(<em>.xcresult*文件)及相关命令(<code>xccov view</code>等)有较大更新，请参考 <a href="https://developer.apple.com/documentation/xcode_release_notes/xcode_11_release_notes?language=objc" target="_blank" rel="noopener">https://developer.apple.com/documentation/xcode_release_notes/xcode_11_release_notes?language=objc</a>。主要的变化是   *.xcresult</em> 文件中<strong>不再包含</strong> <em>.xccovarchive</em> 文件。</p>
</blockquote>
<p>本文涉及的所有脚本均托管在GitHub项目<a href="https://github.com/JerryChu/UnitTestParser" target="_blank" rel="noopener">UnitTestParser</a>中。</p>
<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul>
<li><a href="#单元测试基础">单元测试基础</a></li>
<li><a href="#单元测试概况统计">单元测试概况统计</a></li>
</ul>
<br/>

<h2 id="单元测试基础"><a href="#单元测试基础" class="headerlink" title="单元测试基础"></a>单元测试基础</h2><h3 id="单元测试命令"><a href="#单元测试命令" class="headerlink" title="单元测试命令"></a>单元测试命令</h3><p>执行如下命令即可进行单元测试。单元测试过程中产生的文件存放在<code>BUILD_DIR</code>目录。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># resultBundleVersion 为可选参数，为了防止后续版本更新导致结果文件变化，建议加上这个参数</span><br><span class="line"></span><br><span class="line"># for xcodeproj</span><br><span class="line">xcodebuild test -project Demo.xcodeproj -scheme Demo -derivedDataPath &quot;$&#123;BUILD_DIR&#125;&#x2F;&quot; -destination &quot;$&#123;SIMULATOR_PLATFORM&#125;&quot; -resultBundlePath &quot;$&#123;XCRESULT_PATH&#125;&quot; -resultBundleVersion 3</span><br><span class="line"></span><br><span class="line"># for xcworkspace</span><br><span class="line">xcodebuild test -workspace Demo.xcworkspace -scheme Demo -derivedDataPath &quot;$&#123;BUILD_DIR&#125;&#x2F;&quot; -destination &quot;$&#123;SIMULATOR_PLATFORM&#125;&quot; -resultBundlePath &quot;$&#123;XCRESULT_PATH&#125;&quot; -resultBundleVersion 3</span><br></pre></td></tr></table></figure>

<p><code>SIMULATOR_PLATFORM</code>指定使用的模拟器类型，如。不同机器上可用的模拟器类型不同，如 <em>platform=iOS Simulator,OS=13.4,name=iPhone 11</em>，不同机器上可用的模拟器类型不尽相同，可以通过如下命令获取可用的模拟器列表</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xcrun simctl list</span><br></pre></td></tr></table></figure>

<p><code>XCRESULT_PATH</code>指定单元测试结果文件（<em>.xcresult</em>文件）的存放路径，这个参数是Xcode11的命令行工具中新增加的，便于直接获取到结果文件。使用Xcode10及之前版本时，我们必须去<em>BUILD_DIR</em>对应的目录中找这个文件。（其实在Xcode11中，.xcresult文件在<em>BUILD_DIR</em>对应的目录中也会有一份拷贝，不过当然是直接指定结果文件路径来的方便。）</p>
<h3 id="单元测试结果"><a href="#单元测试结果" class="headerlink" title="单元测试结果"></a>单元测试结果</h3><p>单元测试执行完成之后，就可以在<code>XCRESULT_PATH</code>找到产生的结果文件，也就是 <em>.xccresult</em> 文件。该文件打开后的目录格式为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── Data&#x2F;</span><br><span class="line">│   ├── data0~xxx</span><br><span class="line">│   └── data0~xxx</span><br><span class="line">│ </span><br><span class="line">└── Info.plist</span><br></pre></td></tr></table></figure>

<p>通过解析这些文件，就可以获得单元测试概况、代码覆盖率等基本的单元测试数据。  </p>
<blockquote>
<p><em>.xcresult</em> 文件也支持直接在Xcode中打开，双击打开后就可以在Xcode中看到本次单元测试的详情。</p>
</blockquote>
<h2 id="单元测试概况统计"><a href="#单元测试概况统计" class="headerlink" title="单元测试概况统计"></a>单元测试概况统计</h2><p>单元测试概况统计需要使用官方提供的<code>xcrun xcresulttool</code>工具。  </p>
<p>首先需要获取到出json格式的数据，并从json数据中解析出获取单元测试报告所需的<strong>id</strong>：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 解析成json数据，便于下一步获取id</span></span><br><span class="line">xcrun xcresulttool get --format json --path path/to/xcresult_file</span><br></pre></td></tr></table></figure>

<p>从json数据中获取id需要一连串复杂的json字段解析，这里我参考了<a href="https://github.com/fastlane-community/trainer/blob/307d52bd6576ceefc40d3f57e34ce3653af10b6b/lib/trainer/xcresult.rb" target="_blank" rel="noopener">fastlane的xcresult解析脚本</a>，不再自己重新写一遍id提取逻辑。  </p>
<p>获取到id之后，就能进一步拿到详细的单元测试报告数据。 </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xcrun xcresulttool get --format json --path path/to/xcresult_file --id $id</span><br></pre></td></tr></table></figure>

<p>执行上面的命令之后，又可以获取到了一份json数据，继续解析这份json数据，就可以拿到需要的单元测试总用例数、失败用例数、告警数、执行时长等数据。这里同样参考上面提到的<a href="https://github.com/fastlane-community/trainer/blob/307d52bd6576ceefc40d3f57e34ce3653af10b6b/lib/trainer/test_parser.rb" target="_blank" rel="noopener">fastlane的xcresult解析脚本</a>。</p>
<p>为了简化上述逻辑，<a href="https://github.com/JerryChu/UnitTestParser" target="_blank" rel="noopener">UnitTestParser</a>项目提供了 <a href="https://github.com/JerryChu/UnitTestParser/blob/master/unitTestInfo.rb" target="_blank" rel="noopener"><em>unitTestInfo.rb</em></a> 来直接提取需要的数据。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ruby unitTestInfo.rb --xcresult-path=path/to/xcresult_file --output-file=/path/to/output_file</span><br></pre></td></tr></table></figure>

<p>例如执行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">╰─± ruby ..&#x2F;UnitTestParser&#x2F;unitTestInfo.rb --xcresult-path&#x3D;result.xcresult --output-file&#x3D;result.txt</span><br><span class="line">单元测试用例数：15</span><br><span class="line">失败单元测试用例数：0</span><br><span class="line">单元测试运行总时长：0.48s</span><br></pre></td></tr></table></figure>

<p>同时这些数据也会被写入到 <em>result.txt</em> 文件中，便于其他工具读取。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">╰─± cat result.txt</span><br><span class="line">15</span><br><span class="line">0</span><br><span class="line">0.48</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://blog.jerrychu.top/2019/05/19/singleton/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="JerryChu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="++">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/05/19/singleton/" class="post-title-link" itemprop="url">谈谈单例设计模式</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2019-05-19 22:48:16 / Modified: 23:01:38" itemprop="dateCreated datePublished" datetime="2019-05-19T22:48:16+08:00">2019-05-19</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><strong>单例模式</strong> 是最常被开发者使用的设计模式之一，同时，可能也是最常被 <strong>滥用</strong> 的设计模式之一。  </p>
<p>关于单例模式的好处，网上有很多资料，这里就不再赘述了。本文以iOS 为例，探讨下单例可能带来哪些使用上的问题，以及如何避免这些问题。</p>
<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><ul>
<li><p>不必要的提前初始化 </p>
<p>  由于单例模式的特点，当我们访问单例对象的任何一个属性时，都会造成单例对象的初始化。很多时候，我们在调用单例对象的时候，并没有意识到这样调用带来的副作用，就导致了很多单例对象被提前初始化。  </p>
<p>  假设我们有一个播放器单例类<code>CVideoPlayerManager</code>，这个单例类负责所有视频的播放。</p>
  <figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CVideoPlayerManager.h</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">CVideoPlayerManager</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">BOOL</span> enableRotation; <span class="comment">// 是否允许播放器旋转 </span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)playWithURL:(<span class="built_in">NSURL</span> *)url;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// CVideoPlayerManager.m</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">CVideoPlayerManager</span></span></span><br><span class="line"></span><br><span class="line">+ (CVideoPlayerManager *)sharedInstance &#123;                    </span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> once;                </span><br><span class="line">    <span class="keyword">static</span> CVideoPlayerManager *manager;              </span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;once, ^&#123;                            </span><br><span class="line">        manager = [[CVideoPlayerManager alloc] init]; </span><br><span class="line">    &#125;); </span><br><span class="line">    <span class="keyword">return</span> manager;</span><br><span class="line">&#125;   </span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)init &#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="comment">// 播放器初始化</span></span><br><span class="line">        <span class="comment">// 播放视图初始化</span></span><br><span class="line">        <span class="comment">// 通知注册</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  正常情况下，当我们第一次播放视频的时候，播放器才会被初始化。但是有时候我们在程序启动后，就想更新播放器的一些配置项，比如：</p>
  <figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[CVideoPlayerManager sharedInstance].enableRotation = <span class="literal">NO</span>;</span><br></pre></td></tr></table></figure>

<p>  写完这句代码之后，播放器的配置就生效了，需求搞定！但是仔细看一下，这里调用了 <code>[CVideoPlayerManager sharedInstance]</code>方法，也就是说代码执行到这一行的时候，播放器实例就会被初始化了。而播放器的初始化代码里，往往包含着比较复杂的逻辑，这样的提前初始化，不仅仅导致了内存中过早的出现了一个播放器对象，更可能会造成代码逻辑上的问题。<br>  如果播放器单例初始化代码里还调用了一些其他单例类的方法，然后这些个单例类的初始化方法里又调用了再其他类的单例方法，整个应用程序内部的单例生命周期就会变的异常混乱。</p>
</li>
<li><p>忘记销毁单例类</p>
<p>  单例类使用起来很方便，我们也都知道单例类在内存中只会有一个对象（也可以创建多个对象，这里不展开说明了），但是我们经常会忘记单例对象有时也是需要 <strong>销毁</strong> 的。很多情况下，我们创建的单例类并不需要存在于应用程序的整个生命周期。比如用户关闭某个模块后，这些模块特有的一些单例对象就不需要了，如果我们不把它们清理掉，它们就会一直保留在内存中。占用内存不说，还有可能执行一些不该执行的逻辑，带来安全隐患。</p>
<p>  考虑有一个音频播放器单例，这个音频播放器有一个对应的播放控件，它需要随着页面的切换不断更新，重新attach到当前页面上；同时，当用户主动关闭音频播放控件时，音频停止播放同时把播放控件从页面上移除。<br>  由于这个播放控件需要出现在应用程序的各个页面上，我们把这个播放器设计成了一个单例类</p>
  <figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CAudioPlayerManager.h</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">CAudioPlayerManager</span></span></span><br><span class="line"></span><br><span class="line">+ (<span class="built_in">CAudioPlayerManager</span> *)sharedInstance;</span><br><span class="line">- (<span class="keyword">void</span>)playWithURL:(<span class="built_in">NSURL</span> *)url;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// CAudioPlayerManager.m</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">CAudioPlayerManager</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">CAudioPlayerManager</span> *s_manager</span><br><span class="line">+ (<span class="built_in">CAudioPlayerManager</span> *)sharedInstance &#123;                    </span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> once;                </span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;once, ^&#123;                            </span><br><span class="line">        s_manager = [[<span class="built_in">CAudioPlayerManager</span> alloc] init]; </span><br><span class="line">    &#125;); </span><br><span class="line">    <span class="keyword">return</span> s_manager;</span><br><span class="line">&#125;   </span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)init &#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="comment">// 初始化</span></span><br><span class="line">        <span class="comment">// 监听页面切换通知</span></span><br><span class="line">        [[<span class="built_in">NSNotificationCenter</span> defaultCenter] addObserver:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(_handlePageChanged:) name:CPageChangedNotification];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;               </span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)_handlePageChanged:(<span class="built_in">NSNotification</span> *)notificaion &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"page changed."</span>);</span><br><span class="line">    [<span class="keyword">self</span> reAttach];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)reAattach &#123;</span><br><span class="line">    <span class="comment">// 将播放条重新添加到当前页面上</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  我们看到，<code>CAudioPlayerManager</code>是一个单例类，它监听了当前页面变化的通知，并在收到通知后有一些处理逻辑。当需要播放音频时，我们创建一个该单例的对象，然后去执行相关的逻辑，这都没问题。<br>  但是，当用户关闭这个音频播放控件时，整个音频播放器就在页面上不存在了。而<code>CAudioPlayerManager</code>里并没有提供一个销毁单例的方法。也就是说，虽然我们把播放器关闭了，也把音频播放控件从页面上移除了，但是<code>CAudioPlayerManager</code>的这个单例还一直存在于内存中。它还会继续监听页面变化的通知，继续执行处理逻辑。如果 <code>reAattach</code> 方法里没有进行完备的状态检验，这时候的代码可能就出问题了。再者，退一步说，即使不会对代码逻辑造成影响，<code>_handlePageChanged:</code>方法里的 <code>NSLog</code> 也会一直输出，污染了设备日志。</p>
</li>
</ul>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>说了这么多，那该如何去避免这些问题呢？这就需要我们合理地使用单例，不要不分场景地滥用单例。</p>
<ul>
<li><p>这个类是否有必要作为单例类。</p>
<p>  很多时候，我们都并不是需要一个单例类，而只是为了图方便，所以把它直接设计成一个单例类。这就需要我们在写代码之前，就想清楚自己是不是必须要使用单例模式，详细考虑单例模式的优缺点以及可能遇到的问题，比如创建实例的开销如何，是否有很多全局状态需要保存等。<br>  比如上面提到的视频播放器类 <code>CVideoPlayerManager</code>，其实不一定非得是一个单例类。我们只需要每次在播放视频时，重新创建一个播放器实例即可，这样也能避免很多全局状态带来的逻辑问题。当然一些全局的配置可以单独放到一个单例类里去，做统一的管理。</p>
</li>
</ul>
<ul>
<li><p>即使有些全局状态需要保存，也不一定非得用单例类来实现。</p>
<p>  我们在使用单例类时，经常是为了保存一些全局状态。但是即使是要保存全局状态，也不一定非要把这个类作为单例类使用。我们可以使用<code>static</code>变量来维护一个全局对象。<br>  下面提供一个简单的代码示例来说明如何使用static变量而不是单例类来维护全局对象。这里并不是说就不让用单例，只是提供另外一个可行的方案。大家在写代码时，还是需要自己去思考用那种实现方式比较合理。</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; CDataUtils.h</span><br><span class="line">@interface CDataUtils</span><br><span class="line"></span><br><span class="line">+ (NSString *)urlAtIndex:(NSInteget)index;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; CDataUtils.m</span><br><span class="line">static NSArray&lt;NSString *&gt; *s_urlList &#x3D; nil;</span><br><span class="line"></span><br><span class="line">@implementation CDataUtils</span><br><span class="line"></span><br><span class="line">+ (void)initialize &#123;</span><br><span class="line">    static dispatch_once_t once;</span><br><span class="line">    dispatch_once(&amp;once, ^&#123;</span><br><span class="line">        s_urlList &#x3D; ...;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (NSString *)urlAtIndex:(NSInteget)index &#123;</span><br><span class="line">    return [urlList objectAtIndex:index];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<p>  这样还有一个好处是，当我们需要给<code>CDataUtils</code>添加更多的类方法时，不会带来任何副作用。因为调用类方法不会涉及到任何实例的初始化。</p>
</li>
<li><p>为单例提供一个销毁实例的方法</p>
<p>  如果是像上面说的<code>CAudioPlayerManager</code>这种需要销毁当前实例的单例类，我们可以给单例类提供一个销毁实例的方法。这样当我们不想要当前的实例时，就可以直接调用这个方法把实例从内存中移除。<br>  同时，我们还需要提供一个判断当前是否有实例的方法，如果当前没有实例，同时也不需要去创建一个新的实例，那么就可以直接把调用逻辑return调，防止错误地创建了新的实例。</p>
  <figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CAudioPlayerManager.h</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">CAudioPlayerManager</span></span></span><br><span class="line"></span><br><span class="line">+ (<span class="built_in">CAudioPlayerManager</span> *)sharedInstance;</span><br><span class="line">+ (<span class="keyword">void</span>)dispose;</span><br><span class="line">+ (<span class="built_in">BOOL</span>)isSingletonDisposed;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// CAudioPlayerManager.m</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">CAudioPlayerManager</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">CAudioPlayerManager</span> *s_manager;              </span><br><span class="line">+ (<span class="built_in">CAudioPlayerManager</span> *)sharedInstance &#123;                    </span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> once;                </span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;once, ^&#123;                            </span><br><span class="line">        s_manager = [[<span class="built_in">CAudioPlayerManager</span> alloc] init]; </span><br><span class="line">    &#125;); </span><br><span class="line">    <span class="keyword">return</span> s_manager;</span><br><span class="line">&#125;   </span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">void</span>)dispose &#123;                                      </span><br><span class="line">    <span class="keyword">if</span> (s_manager) &#123;                            </span><br><span class="line">        s_manager = <span class="literal">nil</span>;</span><br><span class="line">    &#125;                           </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="built_in">BOOL</span>)isSingletonDisposed &#123;</span><br><span class="line">    <span class="keyword">return</span> s_manager == <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>单例模式是个非常好用也非常实用的设计模式，但是任何设计模式，一旦滥用，都会带来很多问题，单例模式更是这样。合理使用单例模式，需要我们在写下决定使用单例之前，想清楚是否该使用单例模式，是否有其他更好的替代方案。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://blog.jerrychu.top/2018/11/04/macos-devtool-for-ios/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="JerryChu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="++">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/11/04/macos-devtool-for-ios/" class="post-title-link" itemprop="url">iOS开发之桌面辅助开发工具</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2018-11-04 21:07:49" itemprop="dateCreated datePublished" datetime="2018-11-04T21:07:49+08:00">2018-11-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-05-19 23:01:38" itemprop="dateModified" datetime="2019-05-19T23:01:38+08:00">2019-05-19</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>在日常开发中，我们经常需要通过scheme打开指定的页面。这时候我们一般会在打开手机 <em>Safari</em> ，在地址输入框中输入<code>myapp://somepage?pageid=xxx</code>进行页面的跳转。但是由于移动手机的尺寸限制，每次输入这些scheme都挺繁琐，效率低且容易出错。如果能直接在电脑上输入scheme，然后就能打开手机APP里的指定页面，那该多好啊。</p>
<blockquote>
<p>模拟器可以直接通过 <code>xcrun simctl openurl booted scheme</code> 打开scheme  </p>
</blockquote>
<p>考虑到需要在电脑上控制手机里的APP，那就肯定需要电脑和手机进行通信了，这里主要想到两种方式：  </p>
<ul>
<li>使用WiFi连接，电脑和手机连接到同一个局域网中，使用socket通过网络协议通信。 </li>
<li>使用USB连接，将电脑和手机直接连接在一起。</li>
</ul>
<p>WiFi连接的问题是连接不稳定，容易断开，我们从Xcode的无线调试功能中也能领略到。<br>USB连接的话，既然是有线连接，稳定性自然得到了保证，也不需要切换网络。但是如何通过USB来进行电脑和手机的通性呢？会不会开发起来很复杂？</p>
<p>进一步研究发现，Apple提供了一个叫 <code>usbmux</code>的东西来实现电脑和手机基于USB的通信，iTunes和Xcode都用到了这个东西，所以通过USB连接进行通信方案肯定是可行的了。  </p>
<p>接下来就是好好研究研究<code>usbmux</code>了，苹果的官方文档是这样说的：  </p>
<blockquote>
<p>During normal operations, iTunes communicates with the iPhone using something called “usbmux” – this is a system for multiplexing several “connections” over one USB pipe. Conceptually, it provides a TCP-like system – processes on the host machine open up connections to specific, numbered ports on the mobile device. (This resemblance is more than superficial – on the mobile device, usbmuxd actually makes TCP connections to localhost using the port number you give it.)</p>
</blockquote>
<p>简单翻译一下，就是<code>usbmux</code>在USB协议上实现多路TCP连接，将USB通信抽象为TCP通信。这样一来，通过USB连接电脑和手机之后，电脑和手机就可以通过建立TCP连接进行通信了！这样说可能有些抽象，下面通过这个图来简要介绍下基于<code>usbmux</code>的电脑和手机通信流程。 </p>
<p><img src="https://wx1.sinaimg.cn/mw690/83e01499ly1fwwc0ffnz8j216u0ugdip.jpg" alt="img"></p>
<ol>
<li>电脑端iTunes或其他第三方应用程序向<code>usbmuxd</code>发起连接，请求获取USB连接的通知。</li>
<li>手机通过USB连接到电脑上</li>
<li><code>usbmuxd</code>监听到有手机连接，并向手机发送一个packet</li>
<li>手机回复</li>
<li><code>usbmuxd</code>确认手机已经成功连接，并通知电脑端应用程序</li>
<li>电脑端应用程序向<code>usbmuxd</code>发起建立新的一条连接，请求连接手机的指定端口</li>
<li><code>usbmuxd</code>向手机发送“假的TCP”（基于USB的TCP） SYN packet</li>
<li>手机收到SYN packet并在指定端口打开TCP连接</li>
<li>手机回复 TCP SYN/ACK 确认端口已经打开可以进一步建立连接</li>
<li><code>usbmuxd</code>向手机发送 ACK 完成握手</li>
<li><code>usbmuxd</code>向电脑端应用程序发送连接建立成功的通知 </li>
<li>之后电脑端应用程序向<code>usbmuxd</code>发送的socket，都会经过USB-TCP协议发送到手机的指定端口上，然后手机端的应用程序可以通过监听该端口接受信息。手机向电脑传递信息，也是一样的流程。</li>
</ol>
<p>开源库<a href="https://github.com/rsms/peertalk" target="_blank" rel="noopener">Peertalk</a>就是封装了上面的一套流程，并提供了发起连接的接口以及收发消息的端口。这样一来，我们可以直接使用 <em>Peertalk</em> 实现基于USB的电脑和手机通信了。  </p>
<p>下面以电脑端发送scheme信息给手机端应用程序为例，介绍下使用Peertalk进行通信的流程。</p>
<ul>
<li>电脑端应用程序需要监听手机连接的通知</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">- (void)startListeningForDevices &#123;</span><br><span class="line">  NSNotificationCenter *nc &#x3D; [NSNotificationCenter defaultCenter];</span><br><span class="line">  </span><br><span class="line">  [nc addObserverForName:PTUSBDeviceDidAttachNotification object:PTUSBHub.sharedHub queue:nil usingBlock:^(NSNotification *note) &#123;</span><br><span class="line">  	&#x2F;&#x2F; 手机插入处理</span><br><span class="line">  	&#x2F;&#x2F; ...</span><br><span class="line">  	&#x2F;&#x2F; 建立连接</span><br><span class="line">	[self connectToUSBDevice];</span><br><span class="line">  &#125;];</span><br><span class="line">  </span><br><span class="line">  [nc addObserverForName:PTUSBDeviceDidDetachNotification object:PTUSBHub.sharedHub queue:nil usingBlock:^(NSNotification *note) &#123;</span><br><span class="line">  	&#x2F;&#x2F; 手机拔出处理</span><br><span class="line">  &#125;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)connectToUSBDevice &#123;</span><br><span class="line">  PTChannel *channel &#x3D; [PTChannel channelWithDelegate:self];</span><br><span class="line">  [channel connectToPort:PTExampleProtocolIPv4PortNumber overUSBHub:PTUSBHub.sharedHub deviceID:connectingToDeviceID_ callback:^(NSError *error) &#123;</span><br><span class="line">  	&#x2F;&#x2F; 连接建立成功</span><br><span class="line">  &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>电脑端发出信息</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (IBAction)sendMessage:(id)sender &#123;</span><br><span class="line">    NSString *message &#x3D; @&quot;qqnews:&#x2F;&#x2F;detail?newsid&#x3D;xxx&amp;commentid&#x3D;xxx&quot;;</span><br><span class="line">    dispatch_data_t payload &#x3D; PTExampleTextDispatchDataWithString(message);</span><br><span class="line">    [channel sendFrameOfType:PTExampleFrameTypeTextMessage tag:PTFrameNoTag withPayload:payload callback:^(NSError *error) &#123;</span><br><span class="line">    	&#x2F;&#x2F; 发送完成</span><br><span class="line">    &#125;];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>手机端监听该端口并处理接收到的消息</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 监听本地端口</span><br><span class="line">  PTChannel *channel &#x3D; [PTChannel channelWithDelegate:self];</span><br><span class="line">  [channel listenOnPort:PTExampleProtocolIPv4PortNumber IPv4Address:INADDR_LOOPBACK callback:^(NSError *error) &#123;</span><br><span class="line">  &#125;];</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 处理接受到的消息</span><br><span class="line">- (void)ioFrameChannel:(PTChannel*)channel didReceiveFrameOfType:(uint32_t)type tag:(uint32_t)tag payload:(PTData*)payload &#123;</span><br><span class="line">  if (type &#x3D;&#x3D; PTExampleFrameTypeTextMessage) &#123;</span><br><span class="line">    PTExampleTextFrame *textFrame &#x3D; (PTExampleTextFrame*)payload.data;</span><br><span class="line">    textFrame-&gt;length &#x3D; ntohl(textFrame-&gt;length);</span><br><span class="line">    NSString *scheme &#x3D; [[NSString alloc] initWithBytes:textFrame-&gt;utf8text length:textFrame-&gt;length encoding:NSUTF8StringEncoding];</span><br><span class="line">    &#x2F;&#x2F; handle scheme</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样就实现了在电脑端输入scheme打开手机APP指定页面的功能，再也不用在手机 <em>Safari</em> 上输入一长串scheme了！但是这种方式有个缺陷，就是没法通过电脑端传递的scheme冷启动APP，因为接收端口消息并处理的逻辑都是在APP里，APP没启动，这些逻辑自然处理不了。这个问题接下来我会再研究研究。</p>
<p>话说回来，既然知道了如何让电脑和手机通信，那肯定不能仅满足于打开scheme这一个功能了！比如我们可以把客户端的日志通过这个流程发送给电脑，就可以在电脑上实时看客户端日志了。基于这个，我们可以做很多有意思的开发工具。    </p>
<p>另外Facebook开源的桌面开发工具Flipper也使用了Peertalk，提供了查看日志、页面视图等功能，同时支持iOS和android。但是作为一个开发辅助工具，Flipper搞得有点复杂了，各种依赖一大堆，不过其特性的实现代码和设计思想还是值得研究的。 </p>
<h3 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h3><ul>
<li><a href="https://www.theiphonewiki.com/wiki/Usbmux" target="_blank" rel="noopener">https://www.theiphonewiki.com/wiki/Usbmux</a>  </li>
<li><a href="https://cocoapods.org/pods/usbmuxd" target="_blank" rel="noopener">https://cocoapods.org/pods/usbmuxd</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://blog.jerrychu.top/2018/08/05/Xcode-cpd/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="JerryChu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="++">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/08/05/Xcode-cpd/" class="post-title-link" itemprop="url">Xcode重复代码检测</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2018-08-05 18:18:32" itemprop="dateCreated datePublished" datetime="2018-08-05T18:18:32+08:00">2018-08-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-05-19 23:01:38" itemprop="dateModified" datetime="2019-05-19T23:01:38+08:00">2019-05-19</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>随着项目的推进和业务的增长，代码中不可避免地会出现很多重复代码，这些重复代码大多是从某个地方拷贝过去的，所以我们称之为<code>Copy-Paste-Code</code>。尤其是项目成员较多时，大家碰到不太熟悉的业务模块，经常会直接copy前人写好的代码，一来简单迅速，二来风险较低，但却会导致<code>Copy-Paste-Code</code>越来越多。这种代码让项目非常难以维护，一处修改，处处修改。  </p>
<h3 id="重复代码检测工具"><a href="#重复代码检测工具" class="headerlink" title="重复代码检测工具"></a>重复代码检测工具</h3><p>如何找出项目中的重复代码呢？现在有很多的重复代码检测工具（<code>Copy-Paste-Detector</code>，简称<code>CPD</code>）可以帮助我们完成这件事情。<code>CPD</code>的原理比较好理解，就是一个字符串匹配算法。如果两个代码片段完全相同，即认为这两处代码是<code>Copy-Paste-Code</code>。  </p>
<p><a href="https://pmd.github.io/" target="_blank" rel="noopener">PMD</a>是一个比较流行的静态代码分析工具，支持多种语言。我们可以使用其提供的<a href="https://pmd.github.io/pmd-6.6.0/pmd_userdocs_cpd.html" target="_blank" rel="noopener">CPD</a>对OC代码做重复检测。  </p>
<h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><p>使用<code>brew</code>就可以安装<code>PMD</code></p>
<pre><code>brew install pmd</code></pre><p>也可以自行下载源码运行。mac上可以按如下命令执行</p>
<pre><code>$ cd $HOME
$ curl -OL https://github.com/pmd/pmd/releases/download/pmd_releases%2F6.6.0/pmd-bin-6.6.0.zip
$ unzip pmd-bin-6.6.0.zip
$ alias pmd=&quot;$HOME/pmd-bin-6.6.0/bin/run.sh&quot;</code></pre><h4 id="检测"><a href="#检测" class="headerlink" title="检测"></a>检测</h4><p>安装好<code>PMD</code>后，就可以直接检测项目中的重复代码。<code>PMD-CPD</code>有GUI工具，如下命令即可打开</p>
<pre><code>pmd cpdgui </code></pre><p>在GUI工具中选择目录、语言、和检测阈值（demo中使用的是20，实际项目中建议取值在100到150之前，视具体情况而定）后，点击 <em>Go</em> 就可以检测了。</p>
<p><img src="https://wx4.sinaimg.cn/mw690/83e01499gy1ftz11juatyj21kk0uste5.jpg" alt="img"></p>
<p>图中可以很清楚的看到哪些地方存在重复代码。有了这个检测结果，我们就可以拿来做针对性的修改与重构。  </p>
<h3 id="集成到Xcode"><a href="#集成到Xcode" class="headerlink" title="集成到Xcode"></a>集成到Xcode</h3><p>但是，只使用GUI工具检测出来重复还是不能够避免大家写代码时随心所欲的 <strong>Copy-Paste</strong>, 为了进一步规避<code>Copy-Paste-Code</code>，我们决定将这个工具集成到Xcode中去，只要出现了<code>Copy-Paste-Code</code>，让Xcode在编译期就发出警告，督促大家放弃 <strong>Copy-Paste</strong>，花几分钟时间思考更为合理的解决方案。  </p>
<p>为了实现这个目的，我们需要分两步走：  </p>
<ol>
<li>找到所有重复代码及其所在的文件、行数  </li>
<li>在Xcode中将warning展示出来</li>
</ol>
<h4 id="生成检测结果"><a href="#生成检测结果" class="headerlink" title="生成检测结果"></a>生成检测结果</h4><p>第一步使用<code>PMD-CPD</code>就可以实现，上面提到的<code>PMD-CPD</code>不仅有GUI工具，还支持直接将重复代码检测结果以指定格式输出到文件中。</p>
<pre><code>pmd cpd --files Demo --minimum-tokens 20 --language objectivec --encoding UTF-8 --format xml &gt; output.xml</code></pre><p>其中 <em>files</em> 用于指定需要检测的文件列表，<em>minimum-tokens</em> 用于设置最小重复阈值，<em>format</em> 用于指定输出文件的格式。<code>PMD-CPD</code>支持xml、csv、txt等格式，为了方便下一步处理，这里使用xml格式。生成的xml文件结构如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">pmd-cpd</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">duplication</span> <span class="attr">lines</span>=<span class="string">"7"</span> <span class="attr">tokens</span>=<span class="string">"23"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">file</span> <span class="attr">line</span>=<span class="string">"24"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">path</span>=<span class="string">"..Demo/ViewController.m"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">file</span> <span class="attr">line</span>=<span class="string">"36"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">path</span>=<span class="string">"..Demo/ViewController.m"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">codefragment</span>&gt;</span>&lt;![CDATA[- (int)hello0 &#123;</span><br><span class="line">    int a = 0, b = 0;</span><br><span class="line">    int c = a + b;</span><br><span class="line">    return c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (int)hello1 &#123;]]&gt;<span class="tag">&lt;/<span class="name">codefragment</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">duplication</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">pmd-cpd</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="展示Xcode-warnings"><a href="#展示Xcode-warnings" class="headerlink" title="展示Xcode warnings"></a>展示Xcode warnings</h4><p>拿到这个文件后，我们就可以实施第二步了。关于如何实现在Xcode中生成自定义的warning提示，可以参考之前一篇文章<a href="https://jerrychu.github.io/2018/08/05/Xcode-warnings/" target="_blank" rel="noopener">Xcode展示自定义warning提示</a>。简而言之，我们需要在检测出来的每一处重复代码的位置，按如下形式在Xcode中输出一行warning：</p>
<pre><code>echo &quot;${SRCROOT}/Demo/ViewController.m:1:1: warning: xxx copy-paste lines from xxx&quot;    </code></pre><p>在Xcode的 <em>Build Phases</em> 中，我们增加一个新的 _Run Script_，并添加如下代码</p>
<pre><code># 检测并输出结果到output.xml
sh ./pmd_cpd/bin/run.sh cpd --files ${EXECUTABLE_NAME} --minimum-tokens 20 --language objectivec --encoding UTF-8 --format xml &gt; output.xml
# 解析xml并生成Xcode warning
ruby parse.rb</code></pre><p>解析脚本parse.rb代码如下：</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">require</span> <span class="string">'rexml/document'</span></span><br><span class="line"><span class="keyword">include</span> REXML  </span><br><span class="line"></span><br><span class="line">file = File.new(<span class="string">'output.xml'</span>)</span><br><span class="line">doc = Document.new(file)</span><br><span class="line">root = doc.root</span><br><span class="line">root.each_element(<span class="string">'duplication'</span>) &#123; <span class="params">|item|</span> </span><br><span class="line">    duplicatedFiles = []</span><br><span class="line">	item.each_element(<span class="string">'file'</span>) &#123; <span class="params">|file|</span></span><br><span class="line">		duplicatedFiles.push(file)</span><br><span class="line">	&#125;</span><br><span class="line">	item.each_element(<span class="string">'file'</span>) &#123; <span class="params">|file|</span></span><br><span class="line">		duplicatedString = duplicatedFiles.select&#123;<span class="params">|e|</span> e != file&#125;.map &#123;<span class="params">|e|</span> <span class="string">"<span class="subst">#&#123;e.attributes[<span class="string">'path'</span>].split(<span class="string">'/'</span>).last&#125;</span>:<span class="subst">#&#123;e.attributes[<span class="string">'line'</span>]&#125;</span>"</span>&#125;.join(<span class="string">', '</span>)</span><br><span class="line">		puts <span class="string">"<span class="subst">#&#123;file.attributes[<span class="string">'path'</span>]&#125;</span>:<span class="subst">#&#123;file.attributes[<span class="string">'line'</span>]&#125;</span>:1: warning: <span class="subst">#&#123;item.attributes[<span class="string">'lines'</span>]&#125;</span> copy-pasted lines from: <span class="subst">#&#123;duplicatedString&#125;</span>"</span></span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>添加后直接编译，我们就能在Xcode中的warning列表中发现如下warning，大功告成了！</p>
<p><img src="https://wx4.sinaimg.cn/mw690/83e01499gy1ftz1fm7w4zj20g40dkabd.jpg" alt="img"></p>
<p><img src="https://wx4.sinaimg.cn/mw690/83e01499gy1ftz1h2nba0j21j20dgtaq.jpg" alt="img"></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>使用重复代码检测工具可以方便地检测出重复代码，进一步解析检测结果并以warning的形式集成到Xcode中，在编译期间就可以很清晰地看到代码中的warning，方便发现已有重复代码，同时避免产生新的重复代码。</p>
<p>示例项目地址：<a href="https://github.com/JerryChu/Xcode-tips" target="_blank" rel="noopener">https://github.com/JerryChu/Xcode-tips</a>。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://blog.jerrychu.top/2018/08/05/Xcode-warnings/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="JerryChu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="++">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/08/05/Xcode-warnings/" class="post-title-link" itemprop="url">Xcode展示自定义warning提示</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2018-08-05 16:56:47" itemprop="dateCreated datePublished" datetime="2018-08-05T16:56:47+08:00">2018-08-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-05-19 23:01:38" itemprop="dateModified" datetime="2019-05-19T23:01:38+08:00">2019-05-19</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>在 Xcode 的 <em>Build Setting</em> 中，可以进行一些warning设置，便于在编译阶段提前发现代码问题，比如 <em>隐式类型转换</em> 或者 <em>返回类型不匹配</em> 等。但有时我们需要展示一些 <strong>自定义的warning提示</strong> ，最常见就是对代码中的<code>TODO</code>、<code>FIXME</code>等标签进行warning提示，以免之后忘记修改。我们想要的效果是这个样子：</p>
<p><img src="https://wx3.sinaimg.cn/mw690/83e01499gy1ftywvsuc4zj21kw07qq4f.jpg" alt="img"></p>
<h3 id="如何在Xcode中展示warning提示"><a href="#如何在Xcode中展示warning提示" class="headerlink" title="如何在Xcode中展示warning提示"></a>如何在Xcode中展示warning提示</h3><p>如何让 Xcode 展示出我们自定义的waring呢？其实很简单，只要我们按如下格式输出一段文本，Xcode就会把这段文本在对应的位置展示出来。</p>
<pre><code>/path/to/file:row: warning: text
/path/to/file:row:column: warning: text</code></pre><p>那么我们怎么去输出这段文本呢？我们知道Xcode的 <em>Build Phases</em> 中，可以添加 <em>Run Script</em> 。没错，我们只需要在 <em>Run Script</em> 中输出这段文本就行了。  </p>
<p><img src="https://wx4.sinaimg.cn/mw690/83e01499gy1ftywvt6v6aj21900cgq59.jpg" alt="img"></p>
<p>点击图中左上角的“+”，选择 <code>New Run Script Phase</code>，在输入框中添加如下脚本，然后编译。</p>
<pre><code>echo &quot;${SRCROOT}/Demo/ViewController.m:1:1: warning: haha&quot;    </code></pre><p>编译之后，我们就能看到Xcode左侧的warning列表中出现了一条warning，点击这条warning，就能够像Xcode自己输出的warning一样，自动定位到对应的位置。这样我们就能够在<code>ViewController.m</code>的第一行第一列看到一条warning提示。</p>
<p><img src="https://wx2.sinaimg.cn/mw690/83e01499gy1ftywvs5efjj20g0046weu.jpg" alt="img"></p>
<p><img src="https://wx3.sinaimg.cn/mw690/83e01499gy1ftywvso3xnj21j009swg0.jpg" alt="img"></p>
<p>按同样的方法也可以展示自定义的error提示，格式如下：</p>
<pre><code>/path/to/file:row: error: text
/path/to/file:row:column: error: text.</code></pre><h3 id="如何检测代码中的指定标签"><a href="#如何检测代码中的指定标签" class="headerlink" title="如何检测代码中的指定标签"></a>如何检测代码中的指定标签</h3><p>知道了如何展示自定义的warning后，接下来的目标就很清晰了，即如何去找到<code>TODO</code>、<code>FIXME</code>等标签所在的文件及行数。<br>为了实现这个功能，我们需要遍历每一个文件的每一行代码，检测代码中是否出现了对应的标签。这一步我们可以用下面的脚本实现。参考自 <a href="https://krakendev.io/blog/generating-warnings-in-xcode" target="_blank" rel="noopener">https://krakendev.io/blog/generating-warnings-in-xcode</a> 。</p>
<pre><code># 需要检测的标签
TAGS=&quot;TODO:|FIXME:&quot;
# 对目录下所有.m .h文件进行逐行的匹配检测
find &quot;${SRCROOT}&quot; \( -name &quot;*.m&quot; -or -name &quot;*.h&quot; \) -print0 \  
        | xargs -0 egrep --with-filename --line-number --only-matching   &quot;($TAGS).*\$&quot;</code></pre><p>如果有匹配行，那我们就需要按上面提到的指定格式进行输出。由于我们已经能拿到文件地址以及匹配行，所以接下来只需要按格式输出即可。这里使用perl语言可以很方便地实现。</p>
<pre><code>TAGS=&quot;TODO:|FIXME:&quot;  
 find &quot;${SRCROOT}&quot; \( -name &quot;*.m&quot; -or -name &quot;*.h&quot; \) -print0 \  
        | xargs -0 egrep --with-filename --line-number --only-matching   &quot;($TAGS).*\$&quot; \  
     | perl -p -e &quot;s/($TAGS)/ warning: \$1/&quot;</code></pre><p>再次编译，左侧的warning列表中就会出现另一个warning，点击这个warning，会看到所在行有一个<code>TODO:</code>标签。这样就实现了添加自定义warning提示的功能。</p>
<p><img src="https://wx3.sinaimg.cn/mw690/83e01499gy1ftywvsuc4zj21kw07qq4f.jpg" alt="img"></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>了解Xcode展示warning的原理后，我们可以基于这个功能做很多有趣的事情。除了本文提到的对指定标签展示warning提示外，还可以在Xcode中集成重复代码检测工具，或者进行代码风格提示等。Xcode是一个强大的编译器，还有更多有意思的功能等着我们去探索。</p>
<p>示例项目地址：<a href="https://github.com/JerryChu/Xcode-tips" target="_blank" rel="noopener">https://github.com/JerryChu/Xcode-tips</a>。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://blog.jerrychu.top/2018/06/05/WWDC-tech/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="JerryChu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="++">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/06/05/WWDC-tech/" class="post-title-link" itemprop="url">WWDC笔记（技术篇）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2018-06-05 23:06:57" itemprop="dateCreated datePublished" datetime="2018-06-05T23:06:57+08:00">2018-06-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-05-19 23:01:38" itemprop="dateModified" datetime="2019-05-19T23:01:38+08:00">2019-05-19</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>不出所料，<strong>iOS 12</strong> 果然没有什么大改动出现，所有支持 <strong>iOS 11</strong> 的设备都可以升级到 <strong>iOS 12</strong>，称之为 <strong>iOS 11</strong> 的 <em>bugfix</em> 版本也不为过。对开发者来说，这未必不是一件好事，毕竟 <strong>iOS 11</strong> 的bug的确有点多。同时，更少的改动意味着更少的适配工作，大家可以安心的写bug了。  </p>
<p>不过，作为一次大版本更新，<strong>iOS 12</strong> 还是有一些特性可以说一说的。</p>
<ul>
<li><strong>明显的性能提升</strong><br>大会keynote上写着APP启动时间提升了 <strong>(up to)40%</strong>。虽然有个 <em>up to_，但是如果真能有这个级别的提升，那还真挺令人激动的，毕竟大家一直在探索各种降低启动时间的方法。从另一个方面想，<em>_iOS 11</em></em> 到底是有多慢…</li>
</ul>
<p><img src="https://wx4.sinaimg.cn/mw690/83e01499ly1fs2iawktbwj209905etag.jpg" alt="img"></p>
<ul>
<li><p><strong>Siri Shortcut</strong><br>使用 <strong>siri</strong> 完成一系列预定事件，标志着Siri终于支持<code>workflow</code>，看着是个不错的功能。但是明显能感觉到苹果在推进 <strong>Siri</strong> 的路上走得并不快。而且从之前接入<code>SiriKit</code>的经验来看，预计会有不少坑，比如识别的语法太固定，识别的场景太狭窄，而且之前接入<code>SiriKit</code>之后出现各种各样的审核问题和奇怪的崩溃问题让人很心累。希望这一次 <strong>Siri</strong> 可以做得更好。</p>
</li>
<li><p><strong>ARKit</strong><br>今年仍然花了不少时间来讲<code>ARKit</code>，并且发布了<code>ARKit 2</code>。<code>ARKit 2</code>开始支持再拍照时测量尺寸了，这是个挺好用也好玩的功能。只不过 <a href="https://measurekit.com/" target="_blank" rel="noopener">MeasureKit</a> 的开发者可能就没时间这么想了，看来是得赶紧开发点新东西了。同时<code>ARKit 2</code>也支持了在拍摄视频或者视频聊天时实时在头上盖一个（想不到用啥形容词了…）动物，可以实时模拟你的表情。不过既然<code>ARemoji</code>都已经支持模拟真人了，所以被<a href="(https://twitter.com/developar/status/1003959954833924096)">吐槽一下</a>也就很正常了。</p>
</li>
<li><p><strong>Grouped Notifications</strong><br>系统通知终于支持分类了，再也不用被微信通知刷屏了。系统通知的分类会按照APP设置的通知分类来进行组织，属于一类的通知在展示时会叠加在一起，点击之后可以展开全部，并且支持一些自定义的文案。这部分功能需要开发者进行些适配工作（设置指定的属性等），如果不进行适配的话，APP的所有通知默认全部叠加在一起，这很显然是大家不希望看到的。稍后会补充个demo进来。demo：<a href="https://github.com/JerryChu/Demo" target="_blank" rel="noopener">https://github.com/JerryChu/Demo</a></p>
</li>
<li><p><strong>Photos Share</strong><br>在 <strong>iOS 12</strong> 中，相册会自动识别出照片中的联系人并推荐你将此照片分享给该联系人。不仅如此，你的朋友在收到你分享过来的照片之后，系统也会推荐TA礼尚往来地分享一些包含你的照片给你（如果找不到就尴尬了）。这一切都是基于图像识别实现的，所以首先，你得在通讯录里加上你朋友的照片。</p>
</li>
<li><p><strong>Screen Time</strong><br><strong>iOS 12</strong> 在设置页面新增了一个<code>Screen Time（屏幕时间）</code>选项，在这里你可以看到所有APP的使用时长等信息。这下终于能知道时间都去哪儿了。更爆炸的是，这个页面还有一个<code>App Limits（应用限制）</code>功能，可以限制每个APP的使用时长，时间到了之后直接就把应用锁住不让用了，很适合作为一款防沉迷神器。这简直是熊孩子的噩梦，熊孩子家长的福音啊。</p>
</li>
</ul>
<p><img src="https://wx2.sinaimg.cn/mw690/83e01499ly1fs2hg8z30wj20va1von43.jpg" alt="img"></p>
<ul>
<li><p><strong>Group Facetime</strong><br><strong>FaceTime</strong> 支持群聊啦！咦，这好像不是啥新功能，微信不早就可以了吗？！最多支持 <strong>32</strong> 人同时在线群聊哦！呵呵，想象下32个人在一个聊天室里是啥场景，就算手机不爆炸，人也该爆炸了。上限不是20，也不是50，是整整 <strong>32</strong>，看来苹果工程师还是有情怀的。</p>
</li>
<li><p><strong>IAP</strong><br>刚听说微信公众号的赞赏功能又要上线了，苹果还真是做出了让步啊！不过对开发者和测试同学来说，有个更好的消息，sandbox测试账号与实际账号分离出来了，会支持设置一个单独的测试账号，再也不用在手机上来回切换啦！</p>
</li>
</ul>
<p>除此之外，<strong>mac OS</strong> 还有几个比较重要的改动。<strong>mac OS</strong> 延续了名字很难读的特性，<strong>Mojavi</strong>，也不知道是啥，但是看着屏幕背景图还挺好看。<strong>mac OS Mojavi</strong> 支持夜间模式了！体验了下，显得还挺高端的。但是 iOS 目前不支持，所以这部分的适配工作也可以先挂起了🤓。  </p>
<p>最后要说一下Xcode，今年 <strong>Xcode</strong> 有不少新特性加入，个人认为应该是这次 WWDC 最大的亮点了。<strong>Xcode 10</strong> 进一步增加了对<code>gitlab</code>和<code>gitbucket</code>的支持，同时会自动拉取代码，并在可能出现冲突时提前进行提示。同时 <strong>Xcode 10</strong> 支持并行跑单元测试，在代码覆盖率检测等工具上也都有很多的提升，逐渐要长成一个代码编辑器应该有的样子了。。同时 <strong>Xcode</strong> 也支持了夜间模式，让大家在夜深人静的时候能够更舒服地挖坑，苹果真的是很了解码农们的需求啊！</p>
<p>到现在设备都还没挂过，从beta版本的使用情况来看，<strong>iOS 12</strong> 确实还挺稳定的。希望苹果能越来越好！  </p>
<p>基本也就这些了，更多更详细的内容，大家可以看 <strong>WWDC</strong> 的视频。欢迎交流讨论！</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://blog.jerrychu.top/2018/06/04/WWDC-travel/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="JerryChu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="++">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/06/04/WWDC-travel/" class="post-title-link" itemprop="url">WWDC笔记（出行篇）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2018-06-04 08:57:23" itemprop="dateCreated datePublished" datetime="2018-06-04T08:57:23+08:00">2018-06-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-05-19 23:01:38" itemprop="dateModified" datetime="2019-05-19T23:01:38+08:00">2019-05-19</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="门票-amp-签证"><a href="#门票-amp-签证" class="headerlink" title="门票 &amp; 签证"></a>门票 &amp; 签证</h3><p><strong>WWDC2018</strong> 6月4号在圣荷塞会议中心举办。每年的WWDC差不多都是在6月初举办，一般是3月初开始预约报名，3月底就能够知道有没有抽中门票。一万多人民币的门票还能让大家哄抢，苹果爸爸也真是厉害。  </p>
<p>如果抽中了门票，就得赶紧去办签证了(有签证的大神请绕行，谢谢)。美国签证是需要本人面谈的，前期的 <code>DS-160</code> 表格填写需要个一两天，预约面签一般只能约到一两周之后了，而且办理美国签证可能会被 <strong>行政审核</strong>，一旦进入行政审核流程，至少需要 <strong>4周</strong> 才能搞定签证。这样算下来，时间就已经很紧张了。如果直接通过面试，一般一周之内就能拿到签证。所以签证尽量提前办，甚至可以在报名的时候就开始办，即使抽不中，也总有机会去美国玩儿的。  </p>
<p>如果没抽中门票的话，首先恭喜你省下了一万多块钱😂。 不过实在想去的话，还是有些办法的。苹果不允许私下转让门票，但是同一个企业开发者账号下的开发者是可以互相转让的，所以你可以看看公司有没有抽到票不想去的，一手交钱，一手交门票。  </p>
<p>本人一直运气很好，这次也不必多说，肯定是…没抽中！不过幸亏有同事愿意转让，于是一顿操作之后总算是搞定了门票。在此特别感谢给我门票的同事以及本人leader帮忙协调, 让我这次WWDC之行得以实现🙏。  </p>
<p>延续本人运气一直很好的特性，办理签证当然也是顺利地…被行政审核了！其实，没有直接被被拒绝，我已经很满足了，因为本人没出过国白本一个，名下也没有任何固定资产，去面签之前还是很忐忑的。当然，美签的通过率还是很高的，只要不出特殊状况都不会被直接拒绝，只是有些情况容易被行政审核，比如专业或者职业比较敏感。我本科学的是人工智能相关专业，美国最近又谨防大家过去偷技术，所以我这个专业被列为了敏感专业（好像有个敏感专业和敏感职业列表，可以在网上找找）。嗯…，一定是专业敏感导致的，一定不是因为我穷🤫。  </p>
<p>我身边办理美国签证的同事中，一半是直接通过了，一半是行政审核之后也顺利拿到了签证，所以不必太担心。不过，被行政审核之后，一般拿到的都是一年有效期的签证，而不是十年签。之后再想去，只能再花一千多重新办下签证。不管怎样，总的来说通过率还是很高的，所以一定要有信心，面签的时候千万别紧张，要不面签官以为你想搞事情呢，可能就给你挂了。<strong>温馨提示</strong>，进入美国使馆前，需要将所有不相关物品包括手机都寄存起来，寄存时要去旁边的正规的店里寄存，一定 <strong>不要相信！不要相信！不要相信！</strong> 路边极其热情拉着你让你存包的人，要不你会被坑一笔钱。不要问我是怎么知道的。。。  </p>
<h3 id="交通"><a href="#交通" class="headerlink" title="交通"></a>交通</h3><p>去参加WWDC的话，大部分人都会直飞圣荷塞 <code>SJC</code> 或者先飞旧金山 <code>SFO</code> 再转往圣荷塞。如果时间充足，可以先飞旧金山逛一逛，稍作休整再去圣荷塞。美国公共交通不是很完善，线路少且间隔时间较长，如果会开车的话，开车是最优选择。我是对自己车技不是很信任，怕半路出点事不方便，就索性公交出行了。  </p>
<p>从旧金山机场到市区，可以乘坐 <code>BART</code>（Bay Area Railway Transit）轻轨，差不多需要 <strong>10美元</strong>。在美国买公交票也和国内不太一样，需要先查好到某站多少钱，然后把钱放进去，在机器上一顿加加减减，直到正好等于你的票价，最后点一下购买，等出票就行了。也不知道钱选多了会是啥后果。<code>BART</code> 以及后面会提到的 <code>CalTrain</code> 和 <code>VTA</code>（Valley Transportation Authority）都是类似的操作，但是车票还不互通，每次都需要单独购买，比较麻烦。</p>
<p>BART车厢：</p>
<p><img src="https://wx4.sinaimg.cn/mw690/83e01499ly1fs1e3ap40rj21kw23vu0x.jpg" alt="img"></p>
<p>市内游玩的话可以坐 <code>Muni</code>（San Francisco Municipal Railway）公交车，这个票价各种各样比较复杂，不是很清楚。当然你也可以选择暴走，顺路体验下风土人情。不差钱的我当然是选择了这种方式。  </p>
<p>从旧金山到圣荷塞可以坐 <code>CalTrain</code> 火车，票价 <strong>9美元</strong> ，一路上风景还不错，会经过 <code>MountainView</code> 和 <code>斯坦福大学</code> 等地，可以体验体验。只是从旧金山市区走到 <code>CalTrain</code> 火车站中间貌似有一段贫民区，看到很多乞丐，还挺害怕的。美国路上乞丐不少，旧金山尤其多，所以晚上尽量就别出门了。  </p>
<p>CalTrain车厢：</p>
<p><img src="https://wx4.sinaimg.cn/mw690/83e01499ly1fs1e3akjkuj21kw23v1ky.jpg" alt="img">  </p>
<p>CalTrain车票：</p>
<p><img src="https://wx3.sinaimg.cn/mw690/83e01499ly1fs1egp42t6j21kw23vhdu.jpg" alt="img"></p>
<p>如果是坐 <code>CalTrain</code> 从旧金山到圣荷塞的话，需要从 <strong>San Jose Ditridon</strong> 站下车，然后换乘 <code>VTA</code> 小火车，坐两站就可以到WWDC会议举办地 <strong>San Jose Mcentry Convention Center</strong>。这个小火车是全程统一价，<strong>2.5美元</strong>。  </p>
<p>VTA车厢：</p>
<p><img src="https://wx1.sinaimg.cn/mw690/83e01499ly1fs1e3a4yz8j21kw23vnpd.jpg" alt="img"></p>
<p>VTA车票：</p>
<p><img src="https://wx2.sinaimg.cn/mw690/83e01499ly1fs1egovrjlj21kw23vb2a.jpg" alt="img"></p>
<p>总的来说，乘坐公共交通票价还是相对便宜的，只是会略有些麻烦。如果不开车的话，以上的所有行程，都可以使用出租车或者Uber、Lyft代替，只是会有些小贵。我在圣荷塞市内一般都是用Lyft, 几乎随叫随到，很方便。3公里左右的路程差不多需要 <strong>10美元</strong>，还是可以接受的。   </p>
<p>不写了，就介绍到这儿吧，为了抢个好位置，已经排了快3个小时的队了，但是前面已经是人山人海了😵。还剩最后一小时，WWDC 2018，我来啦!  </p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://blog.jerrychu.top/2018/04/07/OC_POP/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="JerryChu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="++">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/04/07/OC_POP/" class="post-title-link" itemprop="url">面向协议的第三方分享模块实现（OC）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2018-04-07 16:40:44" itemprop="dateCreated datePublished" datetime="2018-04-07T16:40:44+08:00">2018-04-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-05-19 23:01:38" itemprop="dateModified" datetime="2019-05-19T23:01:38+08:00">2019-05-19</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>第三方分享模块是各种各样的APP中必不可少的一个模块，最常用的就是分享到微信和QQ。本文基于<code>面向协议编程</code>（Protocol Oriented Programming，POP）的思想，介绍如何实现一个 <strong>简单灵活</strong>、<strong>易于扩展</strong> 的第三方分享模块。</p>
<p>通常，我们需要实现以下几种功能：</p>
<ul>
<li>分享一段文本</li>
<li>分享一张图片</li>
<li>分享一个网页</li>
<li>……</li>
</ul>
<p>文本分享和图片分享比较简单，需要的数据较少。下面以微信的网页分享为例，介绍如何使用面向协议的思想实现分享功能。</p>
<p>网页分享，也就是分享了一个网页，用户在微信或QQ中点击分享card（如下图所示），会跳转到一个网页去。通常，这个分享card需要展示内容标题、内容描述、缩略图等数据，因此进行网页分享时，一般需要传递以下数据：</p>
<p><img src="https://wx2.sinaimg.cn/mw690/83e01499gy1fq45p5hwlxj20mc08zmyo.jpg" alt="img"></p>
<ul>
<li>分享页面的url</li>
<li>分享card的标题</li>
<li>分享card的描述</li>
<li>分享card的缩略图</li>
</ul>
<p>在微信分享SDK中，需要使用到以下两个对象：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">WXMediaMessage</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="comment">/** 标题</span></span><br><span class="line"><span class="comment">* @note 长度不能超过512字节</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">retain</span>) <span class="built_in">NSString</span> *title;</span><br><span class="line"><span class="comment">/** 描述内容</span></span><br><span class="line"><span class="comment">* @note 长度不能超过1K</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">retain</span>) <span class="built_in">NSString</span> *description;</span><br><span class="line"><span class="comment">/** 缩略图数据</span></span><br><span class="line"><span class="comment">* @note 大小不能超过32K</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">retain</span>) <span class="built_in">NSData</span>   *thumbData;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 多媒体数据对象，可以为WXImageObject，WXMusicObject，WXVideoObject，WXWebpageObject等。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">retain</span>) <span class="keyword">id</span>        mediaObject;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">WXWebpageObject</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="comment">/** 网页的url地址</span></span><br><span class="line"><span class="comment">* @note 不能为空且长度不能超过10K</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">retain</span>) <span class="built_in">NSString</span> *webpageUrl;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p>按照<code>面向对象编程</code>的思想，假设要分享的数据是一个<code>ShareModel</code>，你很快就实现了这个功能：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ShareHelper</span></span></span><br><span class="line">+ (<span class="keyword">void</span>)shareObjectToWeixin:(ShareModel *)model &#123;</span><br><span class="line">	WXWebpageObject *object = [WXWebpageObject object];</span><br><span class="line">	object.webpageUrl = model.url;</span><br><span class="line">	WXMediaMessage *message = [WXMediaMessage message];</span><br><span class="line">	message.title = model.title;</span><br><span class="line">	message.description = model.description;</span><br><span class="line">	message.thumbData = model.thumbnailData;</span><br><span class="line">	message.mediaObject = object;</span><br><span class="line">	</span><br><span class="line">	SendMessageToWXReq *req = [[SendMessageToWXReq alloc] init];</span><br><span class="line">	req.message = message;</span><br><span class="line">	[WXApi sendReq:req];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p>代码并不复杂，用着也方便。有一天，产品过来和你说另一个页面也要支持分享。你看到另一个页面分享时用到的对象是<code>AnotherObject</code>，于是你马上<code>Ctrl+C</code>、<code>Ctrl+V</code>，不到一分钟就搞定了这个需求。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ShareHelper</span></span></span><br><span class="line">+ (<span class="keyword">void</span>)shareAnotherObjectToWeixin:(ShareModel *)model &#123;</span><br><span class="line">	WXWebpageObject *object = [WXWebpageObject object];</span><br><span class="line">	object.webpageUrl = model.url;</span><br><span class="line">	WXMediaMessage *message = [WXMediaMessage message];</span><br><span class="line">	message.title = model.title;</span><br><span class="line">	message.description = model.description;</span><br><span class="line">	message.thumbData = model.thumbnailData;</span><br><span class="line">	message.mediaObject = object;</span><br><span class="line">	</span><br><span class="line">	SendMessageToWXReq *req = [[SendMessageToWXReq alloc] init];</span><br><span class="line">	req.message = message;</span><br><span class="line">	[WXApi sendReq:req];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>正当你沉浸在实现需求的喜悦中时，产品又跑过来说，你这个分享功能还需要支持使用动态下发的数据进行分享，你发现需要支持分享词典数据。虽然有些纠结，你还是在<code>ShareHelper</code>中又加了一个方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ShareHelper</span></span></span><br><span class="line">+ (<span class="keyword">void</span>)shareDictionaryToWeixin:(<span class="built_in">NSDictionay</span> *)dict &#123;</span><br><span class="line">	WXWebpageObject *object = [WXWebpageObject object];</span><br><span class="line">	object.webpageUrl = dict[<span class="string">@"url"</span>];</span><br><span class="line">	WXMediaMessage *message = [WXMediaMessage message];</span><br><span class="line">	message.title = dict[<span class="string">@"title"</span>];</span><br><span class="line">	message.description = dict[<span class="string">@"description"</span>];</span><br><span class="line">	message.thumbData = dict[<span class="string">@"thumbnailData"</span>];</span><br><span class="line">	message.mediaObject = object;</span><br><span class="line">	</span><br><span class="line">	SendMessageToWXReq *req = [[SendMessageToWXReq alloc] init];</span><br><span class="line">	req.message = message;</span><br><span class="line">	[WXApi sendReq:req];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p>实现功能之后，看着<code>ShareHelper.h</code>，作为一个优秀的程序员，你有点方，因为你感觉到需要提供的接口会越来越多。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ShareHelper</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="comment">// 分享ShareModel数据</span></span><br><span class="line">+ (<span class="keyword">void</span>)shareObjectToWeixin:(ShareModel *)model;</span><br><span class="line"><span class="comment">// 分享AnotherShareModel数据</span></span><br><span class="line">+ (<span class="keyword">void</span>)shareAnotherObjectToWeixin:(ShareModel *)model;</span><br><span class="line"><span class="comment">// 分享Dictionary数据</span></span><br><span class="line">+ (<span class="keyword">void</span>)shareDictionaryToWeixin:(<span class="built_in">NSDictionay</span> *)dict;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p>那么涉及到多种不同数据的分享，有什么比较好的办法能让 <code>ShareHelper</code> 别再继续膨胀下去呢？<br>使用<code>面向协议编程</code>的思想来分析这个问题，就会豁然开朗了。<br>从分享模块本身来说，其实它并不需要关注外部传递的是<code>ShareModel</code>、<code>AnotherShareModel</code>还是<code>NSDcitionary</code>，它只需要 <strong>网页url</strong> 、 <strong>标题</strong> 、 <strong>简介</strong> 、 <strong>缩略图</strong> 这四个数据。因此，无论是什么对象，只要能提供这四个数据，分享模块就可以把它分享出去。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">Shareable</span> &lt;<span class="title">NSObject</span>&gt;</span></span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSString</span> *)shareTitle;</span><br><span class="line">- (<span class="built_in">NSString</span> *)shareDescription;</span><br><span class="line">- (<span class="built_in">NSString</span> *)shareUrl;</span><br><span class="line">- (<span class="built_in">NSData</span> *)shareThumbnailData;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p>定义好这个协议之后，<code>ShareHelper</code>会变得非常简单：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ShareHelper</span> : <span class="title">NSObject</span></span></span><br><span class="line">+ (<span class="keyword">void</span>)shareToWeixin:(<span class="keyword">id</span>&lt;Shareable&gt;)shareableModel;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ShareHelper</span></span></span><br><span class="line">+ (<span class="keyword">void</span>)shareToWeixin:(<span class="keyword">id</span>&lt;Shareable&gt;)shareableModel &#123;</span><br><span class="line">	WXWebpageObject *object = [WXWebpageObject object];</span><br><span class="line">	object.webpageUrl = [shareableModel shareUrl];</span><br><span class="line">	WXMediaMessage *message = [WXMediaMessage message];</span><br><span class="line">	message.title = [shareableModel shareTitle];</span><br><span class="line">	message.description = [shareableModel shareDescription];</span><br><span class="line">	message.thumbData = [shareableModel shareThumbnailData];</span><br><span class="line">	message.mediaObject = object;</span><br><span class="line">	</span><br><span class="line">	SendMessageToWXReq *req = [[SendMessageToWXReq alloc] init];</span><br><span class="line">	req.message = message;</span><br><span class="line">	[WXApi sendReq:req];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p>这时，你就可以自豪地和同事们说，以后你们不论想分享啥，只要实现<code>Shareable</code>这个协议，就能给你分享出去！</p>
<p>对于文本分享和图片分享，也只需要提供对应的协议即可，实现了该协议的数据，就可以按照对应的形式分享出去。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">ShareableText</span> &lt;<span class="title">NSObject</span>&gt;</span></span><br><span class="line">- (<span class="built_in">NSString</span> *)shareText;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">ShareableImage</span> &lt;<span class="title">NSObject</span>&gt;</span></span><br><span class="line">- (<span class="built_in">UIImage</span> *)shareImage;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ShareHelper</span> : <span class="title">NSObject</span></span></span><br><span class="line">+ (<span class="keyword">void</span>)shareTextToWeixin:(<span class="keyword">id</span>&lt;ShareableText&gt;)shareableModel;</span><br><span class="line">+ (<span class="keyword">void</span>)shareImageToWeixin:(<span class="keyword">id</span>&lt;ShareableImage&gt;)shareableModel;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p>习惯了<code>面向对象编程</code>之后，我们经常会发现写出的代码不够通用、不好扩展，尤其是对于工具类的方法。如果能将<code>面向对象编程</code>和<code>面向协议编程</code>结合起来使用，扬长避短，经常可以达到事半功倍的效果。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://blog.jerrychu.top/2018/03/25/MainQueue/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="JerryChu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="++">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/03/25/MainQueue/" class="post-title-link" itemprop="url">iOS中的主线程（Main Thread）与主队列（Main Queue）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2018-03-25 19:11:20" itemprop="dateCreated datePublished" datetime="2018-03-25T19:11:20+08:00">2018-03-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-05-19 23:01:38" itemprop="dateModified" datetime="2019-05-19T23:01:38+08:00">2019-05-19</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>iOS编程中，需要在主线程中进行操作时，我们经常会用到以下代码：</p>
<pre><code>dispatch_async(dispatch_get_main_queue(), ^{ 
    // TODO 0:     
});</code></pre><p>仔细观察这部分代码， <em>dispatch_get_main_queue()</em> 实际获取的是 <strong>主队列（Main Queue）</strong> 。我们看<em>dispatch_get_main_queue()</em> 的官方文档：</p>
<blockquote>
<p>Returns the main queue. This queue is created automatically on behalf of the main thread before main() is called.</p>
</blockquote>
<p>而当我们需要判断当前线程是不是 <strong>主线程（Main Thread）</strong> 时，会这样写：</p>
<pre><code>if ([NSThread isMainThread]) {
    // TODO 1:
}</code></pre><p>那么我们会想到以下几个问题： </p>
<p><strong>1. 主线程和主队列到底有什么关系？</strong><br><strong>2. 为什么通过 <em>dispatch_get_main_queue()</em> 就可以确保在代码在主线程执行了？</strong><br><strong>3. 主线程可以执行非主队列里的任务吗？</strong> </p>
<p>我们知道，主队列是系统自动为我们创建的一个串行队列，因此不用我们手动创建。在每个应用程序只有一个主队列，专门负责调度主线程里的任务，不允许开辟新的线程。也就是说，<strong>在主队列里的任务，即使是异步的，最终也只能在主线程中运行</strong>。因此，开头的第一段代码是可以保证在主线程中运行的。我们使用如下代码做测试：</p>
<pre><code>- (void)testMainThread {
    NSLog(@&quot;begin&quot;);
    for (int i = 0 ; i &lt; 10; i ++) {
        dispatch_async(dispatch_get_main_queue(), ^{
            NSLog(@&quot;current Thread: %@; Task: %@&quot;,[NSThread currentThread], @(i));
        });
    }
    NSLog(@&quot;end&quot;);
}</code></pre><p>输出为：</p>
<pre><code>2016-08-28 21:22:18.384 Test[72358:1633765] begin
2016-08-28 21:22:18.384 Test[72358:1633765] end
2016-08-28 21:22:18.388 Test[72358:1633765] isMainThread: 1; Task: 0
2016-08-28 21:22:18.388 Test[72358:1633765] isMainThread: 1; Task: 1
2016-08-28 21:22:18.388 Test[72358:1633765] isMainThread: 1; Task: 2
2016-08-28 21:22:18.388 Test[72358:1633765] isMainThread: 1; Task: 3
2016-08-28 21:22:18.389 Test[72358:1633765] isMainThread: 1; Task: 4</code></pre><p>由于block内的任务是异步执行，主线程在将当前方法（<em>testMainThread</em> ）执行完毕之后，才会去继续执行主队列里的任务。那么如果我们把异步任务换成同步的出现什么结果呢？</p>
<pre><code>- (void)testMainThread {
    NSLog(@&quot;begin&quot;);
    for (int i = 0 ; i &lt; 10; i ++) {
        dispatch_sync(dispatch_get_main_queue(), ^{
            NSLog(@&quot;current Thread: %@; Task: %@&quot;,[NSThread currentThread], @(i));
        });
    }
    NSLog(@&quot;end&quot;);
}</code></pre><p>输出为：</p>
<pre><code>2016-08-28 21:26:29.918 Test[72386:1636378] begin</code></pre><p>也就是说，主线层被阻塞了。这个也好理解，因为此时主队列里的任务是同步执行的，同步任务必需被立刻执行。但同时由于主线程里的<em>testMainThread</em> 还没有执行完，主线程没法去处理主队列里的任务，导致程序死锁。也就是说<strong>主线程空闲时才会调度队列中的任务在主线程执行, 如果当前主线程正在有任务执行，那么无论主队列中当前被添加了什么任务，都不会被调度。</strong> 这也是我们平常写代码需要注意的。</p>
<p>主队列的任务一定在主线程中执行，那么我们再来看最后一个问题：<em>主线程可以执行非主队列里的任务吗？</em>   我们使用下面的代码做测试：</p>
<pre><code> NSLog(@&quot;isMainThread: %@&quot;, @([NSThread isMainThread]));
dispatch_sync(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
    NSLog(@&quot;isMainThread: %@&quot;, @([NSThread isMainThread]));
});</code></pre><p>在主线程中同步执行一个后台队列（使用<em>dispatch_get_global_queue</em>() 方法获取系统创建的全局并发队列）的任务。运行输出为：</p>
<pre><code>2016-08-28 21:55:26.262 Test[72533:1649394] isMainThread: 1
2016-08-28 21:55:26.263 Test[72533:1649394] isMainThread: 1</code></pre><p>可以看到，这个后台队列的任务也是在主线程中执行的。下面是从 <a href="http://blog.benjamin-encz.de/post/main-queue-vs-main-thread" target="_blank" rel="noopener">http://blog.benjamin-encz.de 的一篇博客</a> 摘抄下来的一段说明：</p>
<blockquote>
<p>While doing some research for this post I found <a href="https://libdispatch.macosforge.org/trac/changeset/156" target="_blank" rel="noopener">a commit to libdispatch that ensures that blocks dispatched with dispatch_sync are always executed on the current thread</a>. This means if you use dispatch_sync to dispatch a block from the main queue to a concurrent background queue, the code executing on the background queue will actually be executed on the main thread. While this might not be entirely intuitive, it makes sense: since the main queue needs to wait until the dispatched block completed, the main thread will be available to process blocks from queues other than the main queue.</p>
</blockquote>
<p>所以，主线程是可以执行主队列之外其他队列的任务的。即使<em>[NSThread mainThread]</em> 判断当前线程是主线程，也不能保证当前执行的任务是主队列的任务（系统并没有为我们提供一个判断是不是在主队列的API）。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://blog.jerrychu.top/2018/03/25/CellModel/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="JerryChu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="++">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/03/25/CellModel/" class="post-title-link" itemprop="url">列表性能优化之cell数据缓存</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2018-03-25 18:53:02" itemprop="dateCreated datePublished" datetime="2018-03-25T18:53:02+08:00">2018-03-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-05-19 23:01:38" itemprop="dateModified" datetime="2019-05-19T23:01:38+08:00">2019-05-19</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>通过对列表cell的数据，如cell的高度、subView的布局数据等进行缓存，可以避免不必要的重复计算带来的性能开销，从而实现对列表性能的深度优化。同时可以结合MVVM中ViewModel的概念，进行cell数据的存储，使得代码结构更加清晰。</p>
</blockquote>
<p>在客户端开发中，最经常使用的就是各种列表了，列表性能的好坏，很大程度上决定了一个应用的使用体验如何。关于如何优化列表性能，大家基本都能说出来一些基本方法，比如：</p>
<ul>
<li>cell复用</li>
<li>在子线程进行耗时操作，避免阻塞主线程</li>
<li>避免离屏渲染</li>
<li>图片预处理</li>
<li>减少subView数量</li>
<li>不要给cell动态添加subView</li>
<li>……</li>
</ul>
<p>在实际开发过程中，我们经常会发现，即使已经采用了上面的方法，列表的性能还是不尽如人意。如何能更进一步地进行列表性能的优化呢？下面我们从列表中 <strong>cell的数据缓存</strong> 方面探讨一下解决方案。</p>
<h3 id="cell高度缓存"><a href="#cell高度缓存" class="headerlink" title="cell高度缓存"></a>cell高度缓存</h3><p>对cell高度的缓存已经是业界比较通用的方案。列表每次展现cell时，都会执行回调方法获取cell的高度。</p>
<ul>
<li>列表reload时，会重新计算所有cell的高度。</li>
<li>由于存在cell的复用，当从复用池中取出cell时，需要重新计算cell的高度。</li>
</ul>
<p>正常情况下，每条数据对应的cell高度其实是一定的，当一条数据的对应的cell高度计算出来时，可以将高度<code>存到某个地方</code>，之后再展示这条数据时，就可以直接返回已经计算好的高度。关于cell高度的存储，一般有以下两种方式：</p>
<ol>
<li>存储在<code>Dictionary</code>中<br>这种方式需要每条数据都有一个唯一标识，作为存储高度的<code>key</code></li>
</ol>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// self.cellHeightDict = @&#123;"identifier_0" : "height_0", "identifier_1" : "height_1"&#125;;</span></span><br><span class="line"></span><br><span class="line">- (<span class="built_in">CGFloat</span>)tableView:(<span class="built_in">UITableView</span> *)tableView heightForRowAtIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath &#123;</span><br><span class="line">    <span class="comment">// 获取数据的identifer</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.cellHeightDict[identifier]) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.cellHeightDict[identifier].CGFloatValue;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// calculate height</span></span><br><span class="line">        <span class="keyword">self</span>.cellHeightDict[identifier] = @(height);</span><br><span class="line">        <span class="keyword">return</span> height;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>存储在<code>Model</code>中<br>这种方式将数据计算出的高度作为一个属性，添加到数据对象中。相比于第一种方式，这种方式更易于理解，同时更加安全。</li>
</ol>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Model</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>) <span class="built_in">CGFloat</span> calculatedHeight;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>) <span class="built_in">BOOL</span> isHeightCalculated;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ---</span></span><br><span class="line"></span><br><span class="line">- (<span class="built_in">CGFloat</span>)tableView:(<span class="built_in">UITableView</span> *)tableView heightForRowAtIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath &#123;</span><br><span class="line">    <span class="comment">// 获取数据（model）</span></span><br><span class="line">    <span class="keyword">if</span> (model.isHeightCalculated) &#123;</span><br><span class="line">        <span class="keyword">return</span> model.calculatedHeight;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// calculate height</span></span><br><span class="line">        model.isHeightCalculated = <span class="literal">YES</span>;</span><br><span class="line">        model.calculatedHeight = height;</span><br><span class="line">        <span class="keyword">return</span> height;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>cell高度的缓存很好地结局了高度多次重复计算带来的性能开销。沿着这种思路，我们可以发现需要被缓存的并不只是cell的高度。</p>
<h3 id="cell数据缓存"><a href="#cell数据缓存" class="headerlink" title="cell数据缓存"></a>cell数据缓存</h3><p>cell数据缓存方案不只局限于缓存cell的高度。cell及其subViews的布局数据，以及其他需要进行复杂计算的数据都可以缓存起来。<br>在日常开发过程中，我们经常遇到cell中有若干个垂直排列的label的情况，而每个label的高度都需要动态计算。一般来说，实现代码如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// cell中有两个label垂直排列的情况</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算高度时，需要计算每个label的高度</span></span><br><span class="line">- (<span class="built_in">CGFloat</span>)tableView:(<span class="built_in">UITableView</span> *)tableView heightForRowAtIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath &#123;</span><br><span class="line">    <span class="comment">// 获取数据（model）</span></span><br><span class="line">    <span class="keyword">if</span> (model.isHeightCalculated) &#123;</span><br><span class="line">        <span class="keyword">return</span> model.calculatedHeight;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">CGSize</span> size0 = [model.text0 sizeWithAttributes...];</span><br><span class="line">        <span class="built_in">CGSize</span> size1 = [model.text1 sizeWithAttributes...];</span><br><span class="line">        <span class="built_in">CGFloat</span> height = size0.height + size1.height;</span><br><span class="line">        model.isHeightCalculated = <span class="literal">YES</span>;</span><br><span class="line">        model.calculatedHeight = height;</span><br><span class="line">        <span class="keyword">return</span> height;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 展示时，对label进行布局</span></span><br><span class="line">- (<span class="keyword">void</span>)tableView:(<span class="built_in">UITableView</span> *)tableView willDisplayCell:(<span class="built_in">UITableViewCell</span> *)cell forRowAtIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">CGSize</span> size0 = [model.text0 sizeWithAttributes...];</span><br><span class="line">    label0.text = model.text0;</span><br><span class="line">    label0.frame = (<span class="built_in">CGRect</span>)&#123;<span class="number">0</span>, <span class="number">0</span>, size0.width, size0.height&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">CGSize</span> size1 = [model.text1 sizeWithAttributes...];</span><br><span class="line">    label1.text = model.text1;</span><br><span class="line">    label1.frame = (<span class="built_in">CGRect</span>)&#123;<span class="number">0</span>, <span class="built_in">CGRectGetMaxY</span>(label0.frame), size0.width, size0.height&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于cell的高度，由于已经进行了缓存，没有发生重复计算。但是对于lable的size，每次对cell进行布局时，都会重新计算一遍。实际上，这种的字符串的尺寸计算是非常消耗性能的。因此，这些数据也应该被缓存起来。<br>那么，这些数据该使用哪种方式缓存起来呢？</p>
<ul>
<li>由于同一个identifier会对应多个数据（cell高度，label尺寸等），不适合直接使用词典存储。</li>
<li>把这些数据都作为model的属性，会导致model过于复杂。</li>
</ul>
<p>这种问题很适合使用 <a href="https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93viewmodel" target="_blank" rel="noopener">MVVM架构</a> 来解决。</p>
<h3 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h3><p>在<code>MVVM</code>中，<code>VM(ViewModel)</code>存储着<code>V(View)</code>布局所需要的数据。同样，对于每一个<code>Cell</code>（对应于<code>MVVM</code>中的<code>V(View)</code>），我们都可以创建一个对应的<code>ViewModel</code>来存储它布局所需要的数据。</p>
<p>每条数据（对应于<code>MVVM</code>中的<code>M(Model)</code>）同样需要一个唯一标识，用于存储其对应的<code>ViewModel</code>。基本结构如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ViewModel</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewModel</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>) <span class="built_in">CGFloat</span> height; <span class="comment">// cell高度</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>) <span class="built_in">CGFloat</span> lable0Frame;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>) <span class="built_in">CGFloat</span> lable1Frame;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p>按照这个思路，列表cell布局的基本的代码实现如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// self.viewModelDict = @&#123;"identifier_0" : "viewModel_0", "identifier_1" : "viewModel_1"&#125;;</span></span><br><span class="line"></span><br><span class="line">- (<span class="built_in">CGFloat</span>)tableView:(<span class="built_in">UITableView</span> *)tableView heightForRowAtIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath &#123;</span><br><span class="line">    <span class="comment">// 获取数据的identifer</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.viewModelDict[identifier]) &#123;</span><br><span class="line">        ViewModel *vm = <span class="keyword">self</span>.viewModelDict[identifier];</span><br><span class="line">        <span class="keyword">return</span> vm.heigth;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// calculate viewModel</span></span><br><span class="line">        ViewModel *vm = [ViewModel new];</span><br><span class="line">        <span class="comment">// calculate cellHeight</span></span><br><span class="line">        vm.height = height;</span><br><span class="line">        <span class="comment">// calculate label0's frame</span></span><br><span class="line">        vm.label0Frame = label0Frame;</span><br><span class="line">        <span class="comment">// calculate label1's frame</span></span><br><span class="line">        vm.label1Frame = label1Frame;</span><br><span class="line">        <span class="keyword">self</span>.viewModelDict[identifier] = vm;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> height;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)tableView:(<span class="built_in">UITableView</span> *)tableView willDisplayCell:(<span class="built_in">UITableViewCell</span> *)cell forRowAtIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath &#123;</span><br><span class="line">    <span class="comment">// 获取数据的identifer</span></span><br><span class="line">    ViewModel *vm = <span class="keyword">self</span>.viewModelDict[identifier];</span><br><span class="line"></span><br><span class="line">    label0.text = model.text0;</span><br><span class="line">    label0.frame = vm.label0.frame;</span><br><span class="line"></span><br><span class="line">    label1.text = model.text1;</span><br><span class="line">    label1.frame = vm.label1.frame;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然，上面的ViewModel中并不仅局限于存储height、frame等数据，还可以存储许多布局时需要的数据，比如label对应的text或attributedText等。</p>
<p>总的来说，这种 <strong>Cell数据缓存 + MVVM</strong> 的方式能够避免很多不必要的重复计算带来的性能开销，很好地提升列表的滚动流畅性；同时将计算布局的代码和实际布局UI的代码拆分开，代码结构更加清晰，并且为之后的进一步优化打好了基础（比如将布局代码放到子线程计算）。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://blog.jerrychu.top/2018/01/21/OC_BOOL/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="JerryChu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="++">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/01/21/OC_BOOL/" class="post-title-link" itemprop="url">探索OC中的BOOL类型</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2018-01-21 20:12:20" itemprop="dateCreated datePublished" datetime="2018-01-21T20:12:20+08:00">2018-01-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-05-19 23:01:38" itemprop="dateModified" datetime="2019-05-19T23:01:38+08:00">2019-05-19</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="OC-中的-BOOL"><a href="#OC-中的-BOOL" class="headerlink" title="OC 中的 BOOL"></a>OC 中的 BOOL</h3><p>Obejctive-C 中的 <code>BOOL</code> 类型定义在 <code>&lt;objc.h&gt;</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> (TARGET_OS_IPHONE &amp;&amp; __LP64__) || TARGET_OS_WATCH   </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJC_BOOL_IS_BOOL 1 </span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">bool</span> BOOL; </span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span> </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJC_BOOL_IS_CHAR 1 </span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">signed</span> <span class="keyword">char</span> BOOL; </span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>可见，在32位（准确的说，应该是非64位）机器上，OC中的 <code>BOOL</code> 其实并不是我们熟悉的C语言中的 <code>bool</code> ，而是 <code>signed char</code> 类型，所以OC中的 <code>BOOL</code> 所能存储的数值不止是 0 和 1 ，是 -128~127。</p>
<blockquote>
<p>C99提供了_Bool类型，_Bool依然仍是整数类型，但只能赋值为 0 或 1，非 0 值都会被存储为 1 。<br>C99还提供了<code>&lt;stdbool.h&gt;</code>，其中定义了 bool 代表_Bool，并且定义了 true 和 false，true 代表 1，false 代表 0。</p>
</blockquote>
<p>（所以发明 Objective－C 语言那会儿，C也还没有 bool 类型呢）<br>同时，OC 中还有 <code>YES</code> 和 <code>NO</code> 两个宏，也是在 <code>&lt;objc.h&gt;</code> 中定义，其中 <code>YES</code> 代表 1，<code>NO</code> 代表 0。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __has_feature(objc_bool)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> YES __objc_yes</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NO  __objc_no</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> YES ((BOOL)1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NO  ((BOOL)0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>那么考虑下面这种情况，某个函数返回一个 <code>int</code> 值，在 <code>check</code> 函数中通过判断这个函数的返回值来进行之后的操作，那么在32位的机器中运行，<code>check</code> 函数会打印出 <code>YES</code> 还是 <code>NO</code> 呢？</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">int</span>)returnValue &#123;</span><br><span class="line">	<span class="comment">// use 256 as an example</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">256</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)check &#123;</span><br><span class="line">	BOOL yesOrNo = (BOOL)[self returnValue];</span><br><span class="line">	<span class="keyword">if</span> (yesOrNo) &#123;</span><br><span class="line">		NSLog(@<span class="string">"YES"</span>);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		NSLog(@<span class="string">"NO"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可能大家觉得想都不用想，肯定是输出 <code>YES</code>。那么实际结果可能会让你恨郁闷，因为输出的是 <code>NO</code>。到底是为什么呢？ </p>
<p>还记得文章一开始，我们说32位机器下，OC中的 <code>BOOL</code> 类型实际是 <code>signed char</code>，可以表示-128~127。在执行到 <code>check</code> 方法的第一句时，由于 <code>[self returnValue]</code> 返回的是int类型的数值，所以会进行以下的 <code>int</code> -&gt; <code>signed char（BOOL）</code>类型转换： </p>
<pre><code>BOOL yesOrNo = (BOOL)256;</code></pre><p>而 <code>signed char</code> 占一个字节，也就是8 bit。 256转换成二进制的末16位是 <code>00000001 00000000</code>，强制转换为 <code>signed char</code> 后，取末8位的值 <code>00000000</code>，也就是0。到这里，大家应该意识到，所有末8位全为0的数字，如512、1024…，在32位机器上被强制转换位 <code>BOOL</code> 类型时，都会被转换位 <code>NO(0)</code>。之所以会发生这种“神奇的现象”，是因为32位机器上的 <code>BOOL</code> 类型在“作祟”。<br>指针类型也一样。继续拿上面的代码举例，这次我们把 <code>returnValue</code> 方法改造下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (NSString *)returnValue &#123;</span><br><span class="line">	NSString *someString = @<span class="string">"xxx"</span>;</span><br><span class="line">	<span class="keyword">return</span> someString;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果 <code>someString</code> 为nil，那么没有疑问 <code>check</code>方法会输出 NO。如果 <code>someString</code> 不为nil呢？我们假设 <code>someString</code> 的内存地址为  <code>0xa3b2c100</code>,在将 <code>returnValue</code> 强制转换为 <code>yesOrNo</code> 时，仍然取内存地址的末8位，也就是 <code>0x00</code>，所以yesOrNo的值就是 <code>NO</code> 喽。 当然，只要原字符串的内存地址末8位不全是0，比如<code>0xa3b2c1d0</code> 等，转换后yesOrNo的值就不会为<code>NO</code>。</p>
<hr>
<p>上面说的都是32位机器上才会出现的问题，64位机器上，OC中的BOOL成了真正C语言中的bool，只能存储0和1。所以，在进行类似的类型转换时，只要值不等于0，就会被判为1，不会出现这些问题。但是由于目前iOS仍然需要支持32位的机器，所以平常写代码时还得多多注意。  </p>
<p>目前还能见到的32位的iOS设备有：iPhone4s(A5)、iPhone5(A6)、iPhone5c(A6)、iPod Touch5(A5)、iPad3(A5X)、iPad4（A6X)  </p>
<hr>
<h3 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h3><ul>
<li><a href="https://www.bignerdranch.com/blog/bools-sharp-corners/" target="_blank" rel="noopener">https://www.bignerdranch.com/blog/bools-sharp-corners/</a>  </li>
<li><a href="https://en.wikipedia.org/wiki/List_of_iOS_devices" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/List_of_iOS_devices</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">JerryChu</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">19</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">15</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">JerryChu</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
